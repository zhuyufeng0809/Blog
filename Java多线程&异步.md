## 多线程

### 线程模型

线程的并发执行是由操作系统来进行调度的，操作系统一般都在内核提供对线程的支持。在使用高级语言编写程序时创建的线程是用户线程，那么用户线程与内核线程是什么关系呢？线程模型就是根据用户线程与内核线程关系的不同而划分的

#### 一对一模型

这种线程模型下用户线程与内核线程是一一对应的，当我们使用高级语言创建一个用户线程的时候，其实对应创建了一个内核线程

这种线程模型的优点是，在多处理器上多个线程可以真正实现并行运行，并且当一个线程由于网络IO等原因被阻塞时，其他线程不受影响

缺点是由于一般操作系统会限制内核线程的个数，所以用户线程的个数会受到限制。另外由于用户线程与系统线程一一对应，当用户线程比如执行IO操作（执行系统调用）时，需要从用户态的用户程序执行切换到内核态执行内核操作，然后等执行完毕后又会从内核态切换到用户态执行用户程序，而这个切换操作开销是比较大的

Java的线程模型就是使用的这种一对一的模型

#### 多对一模型

多对一模型是指多个用户线程对应一个内核线程，同一时刻，同一个用户线程只能对应一个内核线程，这时候对应同一个内核线程的多个用户线程的上下文切换是由用户态的运行时线程库来做的，而不是由操作系统调度系统来做的

这种模型的好处是由于上下文切换在用户态，因而切换速度很快，开销很小；另外，可创建的用户线程的数量可以很多，只受内存大小限制

这种模型由于多个用户线程对应一个内核线程，当该内核线程对应的一个用户线程被阻塞挂起时，该内核线程对应的其他用户线程也不能运行，因为这时候内核线程已经被阻塞挂起了。另外这种模型并不能很好地利用多核CPU进行并发运行

#### 多对多模型

多对多模型则结合一对一和多对一模型的特点，让大量的用户线程对应少数几个内核线程，这时候每个内核线程对应多个用户线程，每个用户线程又可以对应多个内核线程，当一个用户线程阻塞后，其对应的当前内核线程会被阻塞，但是被阻塞的内核线程对应的其他用户线程可以切换到其他内核线程上继续运行，所以多对多模型是可以充分利用多核CPU提升运行效能。另外多对多模型也对用户线程个数没有限制，理论上只要内存够用可以无限创建

Go线程模型属于多对多线程模型

### Java多线程简介

#### 进程、线程与任务
**进程是操作系统分配资源的基本单元**，**线程是操作系统调度执行的基本单元**，一个进程可以包含多个线程，同一个进程中的所有线程共享该进程中的资源。启动一个Java程序实质是启动一个JVM进程，线程所要完成的计算逻辑被称为**任务**

https://blog.csdn.net/pange1991/article/details/84770181  

#### Java多线程API

##### 线程的创建、启动与运行
Java标准库类java.lang.Thread就是Java平台对线程的实现。Thread类或其子类的一个实例就是一个线程  

在Java中创建一个线程就是创建一个Thread类（或其子类）的实例  

每个线程都有其要执行的任务。线程的任务处理逻辑可以在Thread类的run实例方法中直接实现或者通过该方法进行调用，因此run方法相当于线程的任务处理逻辑的入口方法，它由Java虚拟机在运行相应线程时直接调用，而不是由应用代码进行调用

运行一个线程实际上就是让Java虚拟机执行该线程的run方法，从而使相应线程的任务处理逻辑代码得以执行。为此首先要启动线程。Thread类的start方法的作用是启动相应的线程。启动一个线程的实质是请求Java虚拟机运行相应的线程，而这个线程具体何时能够运行是由线程调度器（Scheduler，是操作系统的一部分）决定，**应用程序负责线程的创建与启动，而线程调度器负责线程的调度与执行**。因此，start方法调用结束并不意味着相应线程已经开始运行，这个线程可能稍后才被运行，甚至也可能永远不会被运行  

Thread类的两个常用构造器是：Thread()和Thread(Runnable target)相应地，Java语言中创建线程有两种方式。一种是：定义Thread类的子类，在该子类中覆盖(Override)run方法并在该方法中实现线程任务处理逻辑；另一种是：创建一个java.lang.Runnable接口的实例，并在该实例的run方法中实现任务处理逻辑，然后以该Runnable接口实例作为构造器的参数直接创建（new）一个Thread类的实例

```
public class Main {
    public static void main(String[] args) {
        //子类继承
        Thread welcomethread1 = new welcomeThread();
        //实现接口
        Thread welcomethread2 = new Thread(new welcomeTask());

        welcomethread1.start();
        welcomethread2.start();

        System.out.println("finish");
    }
}

class welcomeThread extends Thread{
    @Override
    public void run(){
        System.out.println(Thread.currentThread().getName());
    }
}

class welcomeTask implements Runnable{
    @Override
    public void run(){
        System.out.println(Thread.currentThread().getName());
    }
}
```

不管是采用哪种方式创建线程，一旦线程的run方法执行（由Java虚拟机调用）结束，相应的线程的运行也就结束了。当然，run方法执行结束包括正常结束（run方法返回）以及代码中抛出异常而导致的中止。运行结束的线程所占用的资源（如内存空间）会如同其他Java对象一样被Java虚拟机垃圾回收  

线程属于“一次性用品”，不能通过重新调用一个已经运行结束的线程的start方法来使其重新运行。事实上，start方法也只能够被调用一次，多次调用同一个Thread实例的start方法会导致其抛出IllegalThreadStateException异常  

在Java平台中，一个线程就是一个对象，对象的创建离不开内存空间的分配。创建一个线程与创建其他类型的Java对象所不同的是，Java虚拟机会为每个线程分配调用栈（Call Stack）所需的内存空间。调用栈用于跟踪Java代码（方法）间的调用关系以及Java代码对本地代码（Native Code，通常是C代码）的调用。另外，Java平台中的每个线程可能还有一个内核线程（具体与Java虚拟机的实现有关）与之对应。因此相对来说，创建线程对象比创建其他类型的对象的成本要高一些

Java平台中的任意一段代码（比如一个方法）总是由确定的线程负责执行的，这个线程就相应地被称为这段代码的执行线程。同一段代码可以被多个线程执行。例如，如果以同一个Runnable接口实例作为构造器参数创建多个Thread实例（线程）的话，那么这个Runnable接口实例的run方法就会被多个线程执行。任意一段代码都可以通过调用Thread.currentThread()来获取这段代码的执行线程，这个线程就被称为当前线程。由于同一段代码可以被多个线程执行，因此当前线程是相对的，即概念层次上的当前线程（即Thread.currentThread()的返回值）在代码实际运行的时候可能对应着不同的线程（对象）  

线程的run方法总是由Java虚拟机直接调用的。尽管如此，Java语言并不阻止直接调用run方法，这是因为：首先，线程在Java平台中也是一个对象，其次，run方法也是一个public方法。但是，**多数情况下不能这样做，因为这样做有违创建线程（对象）的初衷**

##### Runnable接口
Thread类实际上是Runnable接口的一个实现类，Runnable接口可以被看作对任务进行的抽象。Runnable接口只定义了一个run方法，任务的处理逻辑就体现在run方法之中，该方法的声明和实现如下

```
public void run() {
    if (target != null) {
        target.run();
    }
}
```

Thread类的run方法中实现的逻辑是如果target不为null，那么就调用target.run()，否则什么也不做。其中，实例变量target的类型为Runnable。如果相应的线程实例是通过构造器Thread（Runnable target）创建的，那么target的值为构造器中的参数值，否则target的值为null。因此，Thread类所实现的任务处理逻辑是要么什么也不做（target为null），要么直接执行target所引用的Runnable实例所实现的任务处理逻辑。Thread类的run方法的这种处理逻辑决定了创建线程的两种方式：一种是在Thread子类的run方法中直接实现任务处理逻辑（Thread类子类重写run方法，覆盖掉父类的run方法），另一种是在一个Runnable实例中实现任务处理逻辑，该逻辑由Thread类的run方法负责调用  

从面向对象编程的角度来看：创建Thread类的子类的方式是一种基于继承（Inheritance）的技术，以Runnable接口实例为构造器参数直接通过new创建Thread实例的方式是一种基于组合（Composition）的技术。由于组合相对继承来说，其类和类之间的耦合性（Coupling）更低，因此更加灵活。一般认为组合是优先选用的技术  

从对象共享的角度来看：以Runnable接口实例为构造器参数直接通过new创建Thread实例的方式意味着多个线程实例可以共享同一个Runnable实例。在某些情况下这可能更容易导致线程安全问题  

##### 线程属性

线程的属性包括线程的编号（ID）、名称（Name）、线程类別（Daemon）和优先级（Priority）

| 属性 | 属性类型及用途 | 只读属性 | 重要注意事项 |
| :----: | :----: | :----: | :----: |
| 编号（ID） | 类型：long。用于标识不同的线程。不同的线程拥有不同的编号 | 是 | 某个编号的线程运行结束后，该编号可能被后续创建的线程使用。不同线程拥有的编号虽然不同，但是这种编号的唯一性只在Java虚拟机的一次运行有效。也就是说重启一个Java虚拟机（如重启Web服务器）后，某些线程的编号可能与上次Java虚拟机运行的某个线程的编号一样，因此该属性的值不适合用作某种唯一标识，特別是作为数据库中的唯一标识（如主键） |
| 名称（Name） | 类型：Sring。面向人（而非机器）的一个属性，用于区分不同的线程。默认值与线程的编号有关，默认值的格式为：“Thread-线程编号”，如“Thread-0” | 否 | Java并不禁止将不同的线程的名称属性设置为相同的值。尽管如此，设置线程的名称属性有助于代码调试和问题定位 |
| 线程类别（Daemon） | 类型：boolean。值为true表示相应的线程为守护线程，否则表示相应的线程为用户线程。该属性的默认值与相应线程的父线程的该属性的值相同 | 否 | 该属性必须在相应线程启动之前设置，即对setDaemon方法的调用必须在对start方法的调用之前，否则setDaemon方法会抛出llegalThreadStateExcepion异常。负责一些关键任务处理的线程不适合设置为守护线程 |
| 优先级（Priority） | 类型：int。该属性本质上是给线程调度器的提示，用于表示应用程序希望哪个线程能够优先得以运行。Java定义了1-10的10个优先级。默认值一般为5（表示普通优先极）。对于具体的一个线程而言，其优先级的默认值与其父线程（创建该线程的线程）的优先级值相等 | 否 | 一般使用默认优先级即可。不恰当地设置该属性值可能导致严重的问题（线程饥饿） |


```
public class Main {
    public static void main(String[] args) {

        Thread welcomethread = new Thread(new Runnable(){
            @Override
            public void run(){
                System.out.println(Thread.currentThread().getId());
                System.out.println(Thread.currentThread().getName());
                System.out.println(Thread.currentThread().isDaemon());
                System.out.println(Thread.currentThread().getPriority());
            }
        });

        welcomethread.start();

        System.out.println("finish");
        System.out.println(Thread.currentThread().getId());
        System.out.println(Thread.currentThread().getName());
        System.out.println(Thread.currentThread().isDaemon());
        System.out.println(Thread.currentThread().getPriority());
    }
}
```

通过名称属性，可以为每个线程设置一个便于区分不同线程的名称。虽然Java虚拟机并不要求每个线程的名称都不同，但是设置该属性有助于程序调试和问题定位。因此，建议为每个线程都设置一个简短而又能够体现其作用或其实现的功能的名称  

线程的属性除了编号外，其他属性都是可读写的属性，即Thread类提供了相应的get方法和set方法用于读取或者设置相应的属性  

Java线程的优先级属性本质上只是一个给线程调度器的提示信息，以便于线程调度器决定优先调度哪些线程运行。它并不能保证线程按照其优先级高低的顺序运行。注意，Java线程的优先级使用不当或者滥用则可能导致某些线程永远无法得到运行，即产生了线程饥饿（Thread Starvation）。因此，线程的优先级并不是设置得越高越好；一般情况下使用普通优先级即可，即不必设置线程的优先级属性  

按照线程是否会阻止Java虚拟机正常停止，可以将Java中的线程分为守护线程（Daemon Thread）和用户线程（User Thread，也称非守护线程）。线程的daemon属性用于表示相应线程是否为守护线程。用户线程会阻止Java虚拟机的正常停止，即一个Java虚拟机只有在其所有用户线程都运行结束（即Thread.run()调用未结束）的情况下才能正常停止。而守护线程则不会影响Java虚拟机的正常停止，即应用程序中有守护线程在运行也不影响Java虚拟机的正常停止。因此，守护线程通常用于执行一些重要性不是很高的任务，例如用于监视其他线程的运行情况  

如果Java虚拟机是被强制停止的，比如在Linux系统下使用kill命令强制终止一个Java虚拟机进程，那么即使是用户线程也无法阻止Java虚拟机的停止

##### Thread类的常用方法和废弃方法

| 方法 | 功能 | 备注 |
| :----: | :----: | :----: |
| static ThreadcurrentThread() | 返回当前线程，即当前代码的执行线程（对象） | 同一段代码对Thread.currentThread()的调用，其返回值可能对应着不同的线程（对象） |
| void run() | 用于实现线程的任务处理逻辑 | 该方法是由Java虚拟机直接调用的，一般情况下应用程序不应该调用该方法 |
| void start() | 启动相应线程 | 该方法的返回并不代表相应的线程已经被启动。一个Thread实例的start方法只能够被调用一次，多次调用会导致异常的抛出 |
| void join() | 等待相应线程运行结束 | 若线程A调用线程B的join方法，那么线程A的运行会被暂停，直到线程B运行结束 |
| static void yield() | 使当前线程主动放弃其对处理器的占用，这可能导致当前线程被暂停 | 这个方法是不可靠的。该方法被调用时当前线程可能仍然继续运行（视系统被暂停当前的运行状况而定） |
| static void sleep(long millis) | 使当前线程休眠（暂停运行）指定的时间 |  |

| 方法 | 功能 |
| :----: | :----: |
| stop | 停止线程的运行 |
| suspend | 暂停线程的运行 |
| resume | 使被暂停的线程继续运行 |

#### 线程的层次关系
假设线程A执行的代码创建了线程B，那么就称线程B为线程A的子线程。相应地线程A就被称为线程B的父线程。子线程所执行的代码还可以创建其他线程，因此一个子线程也可以是其他线程的父线程。所以，父线程、子线程是一个相对的称呼  

线程间的这种父子关系就被称为线程的层次关系。由于Java虚拟机创建的main线程（也被称为主线程）负责执行Java程序的入口方法main方法，因此main方法中直接创建的线程都是main线程的子线程。这些子线程所执行的代码又可能创建其他线程  

在Java平台中，一个线程是否是一个守护线程默认取决于其父线程：默认情况下父线程是守护线程，则子线程也是守护线程；父线程是用户线程，则子线程也是用户线程。另外，父线程在创建子线程后启动子线程之前可以调用该线程的setDaemon方法，将相应的线程设置为守护线程（或者用户线程）  

一个线程的优先级默认值为该线程的父线程的优先级。即如果没有设置或者更改一个线程的优先级，那么这个线程的优先级的值与父线程的优先级的值相等  

不过，Java平台中并没有API用于获取一个线程的父线程，或者获取一个线程的所有子线程。并且，父线程和子线程之间的生命周期也没有必然的联系。比如父线程运行结束后，子线程可以继续运行，子线程运行结束也不妨碍其父线程继续运行  

习惯上，称某些子线程为工作者线程（Worker Thread）或者后台线程（Background Thread）。工作者线程通常是其父线程创建来用于专门负责某项特定任务的执行的。Java虚拟机中对内存进行回收的线程通常被称为GC（Garbage Collection）工作者线程  

#### 线程的生命状态周期
在Java中，一个线程从创建、启动到运行结束的整个生命周期可能经历若干状态  

Java线程的状态可以通过Thread.getState()调用来获取。Thread.getState()的返回值类型Thread.State是一个枚举类型（Enum）。Thread.State所定义的线程状态包括以下几种

* **NEW**：一个已创建而未启动的线程处于该状态。由于一个线程实例只能够被启动一次，因此一个线程只可能有一次处于该状态
* **RUNNABLE**：该状态可以被看成一个复合状态。它包括两个子状态：READY和RUNNING。前者表示处于该状态的线程可以被线程调度器（Scheduler）进行调度而使之处于RUNNING状态。后者表示处于该状态的线程正在运行，即相应线程对象的run方法所对应的指令正在由处理器执行。执行Thread.yield()的线程，其状态可能会由RUNNING转换为READY。处于READY子状态的线程也被称为活跃线程
* **BLOCKED**：一个线程发起一个阻塞式IO（Blocking I/O）操作后，或者申请一个由其他线程持有的独占资源（比如锁）时，相应的线程会处于该状态。处于BLOCKED状态的线程并不会占用处理器资源。当阻塞式IO操作完成后，或者线程获得了其申请的资源，该线程的状态又可以转换为RUNNABLE
* **WAITING**：一个线程执行了某些特定方法之后就会处于这种等待其他线程执行另外一些特定操作的状态。能够使其执行线程变更为WAITING状态的方法包括：Object.wait()、Thread.join()和LockSupport.park(Object)。能够使相应线程从WAITING变更为RUNNABLE的相应方法包括：Object.notify()/notifyAll()和LockSupport.unpark(Object)
* **TIMED_WAITING**：该状态和WAITING类似，差别在于处于该状态的线程并非无限制地等待其他线程执行特定操作。而是处于带有时间限制的等待状态。当其他线程没有在指定时间内执行该线程所期望的特定操作时，该线程的状态自动转换为RUNNABLE
* **TERMINATED**：已经执行结束的线程处于该状态。由于一个线程实例只能够被启动一次，因此一个线程也只可能有一次处于该状态。Thread.run()正常返回或者由于抛出异常而提前终止都会导致相应线程处于该状态

一个线程在其整个生命周期中，只可能有一次处于NEW状态和TERMINATED状态

#### 多线程的优势和风险

多线程编程具有以下优势

* 提高系统的吞吐率（Throughput）。多线程编程使得一个进程中可以有多个并发（Concurrent，即同时进行的）的操作
* 提高响应性（Responsiveness）。在使用多线程编程的情况下，对于GUI软件（如桌面应用程序）而言，一个慢的操作（比如从服务器上下载一个大的文件）并不会导致软件的界面出现被“冻住”的现象而无法响应用户的其他操作；对于Web应用程序而言，一个请求的处理慢了并不会影响其他请求的处理
* 充分利用多核（Multicore）处理器资源。如今多核处理器的设备越来越普及，就算是手机这样的消费类设备也普遍使用多核处理器。实施怡当的多线程编程有助于充分利用设备的多核处理器资源，从而避免了资源浪费
* 最小化对系统资源的使用。一个进程中的多个线程可以共享其所在进程所申请的资源（如内存空间），因此使用多个线程相比于使用多个进程进行编程来说，节约了对系统资源的使用 
* 简化程序的结构。线程可以简化复杂应用程序的结构

多线程编程具有以下问题与风险

* 线程安全（Thread Safe）问题。多个线程共享数据的时候，如果没有采取相应的并发访问控制措施，那么就可能产生数据一致性问题，如读取脏数据（过期的数据）、丢失更新（某些线程所做的更新被其他线程所做的更新覆盖）等
* 线程活性（Thread Liveness）问题。一个线程从其创建到运行结束的整个生命周期会经历若干状态。从单个线程的角度来看，RUNNABLE状态是期望的状态。但实际上，代码编写不当可能导致某些线程一直处于等待其他线程释放锁的状态（BLOCKED状态），即产生了死锁（Deadlock）。当然，一直忙碌的线程也可能会出现问题，它可能面临活锁（Livelock）问题，即一个线程一直在尝试某个操作但就是无法进展。另外，线程是一种稀缺的计算资源，一个系统所拥有的处理器数量相比于该系统中存在的线程数量而言总是少之又少的。某些情况下可能出现线程饥饿（Starvation）的问题，即某些线程永远无法获取处理器执行的机会而永远处于RUNNABLE状态的READY子状态
* 上下文切换（Context Switch）。处理器从执行一个线程转向执行另外一个线程的时候操作系统所需要做的一个动作被称为上下文切换。由于处理器资源的稀缺性，因此上下文切换可以被看作多线程编程的必然副产物，它增加了系统的消耗，不利于系统的吞吐率
* 可靠性。多线程编程一方面可以有利于可靠性，某个线程意外提前终止了，但这并不影响其他线程继续其处理。另一方面，线程是进程的一个组件，它总是存在于特定的进程中，如果这个进程由于某种原因意外提前终止，那么该进程中所有的线程也就随之而无法继续运行。因此，从提高软件可靠性的角度来看，某些情况下可能要考虑多进程多线程的编程方式，而非简单的单进程多线程方式

### 多线程的目标与挑战

#### 申行（Sequential）、并发（Concurrent）与并行（Parallel）
并发是串行的反面，并发往往可以提高对事情的处理效率，即一段时间内可以处理或者完成更多的事情。而并行是一种更为严格、理想的并发，即并行可以被看作并发的一个特例。并发往往是带有部分串行的并发，而并发的极致就是并行（Parallel）。从软件的角度来说，并发就是在一段时间内以交替的方式去完成多个任务，而并行就是以齐头并进的方式去完成多个任务。从硬件的角度来说。在一个处理器一次只能够运行一个线程的情况下，由于处理器可以使用时间片（Time-slice）分配的技术来实现在同一段时间内运行多个线程，因此一个处理器就可以实现并发。而并行则需要靠多个处理器在同一时刻各自运行一个线程来实现。多线程编程的实质就是将任务的处理方式由串行改为并发，即实现并发化，以发挥并发的优势

#### 竞态
程序的输出有时是正确的，有时是错误的，这种一个计算结果的正确性与时间有关的现象就被成为**竞态**（Race Condition）  

共享变量：即可以被多个线程共同访问的变量。共享变量中的共享强调的是可以被共享的可能性，因此称一个变量为共享变量并不表示该变量一定被多个线程访问。类的实例变量、静态变量由于可以被多个线程共享，因此被称为共享变量  

导致竞态的常见因素是多个线程在没有采取任何并发控制措施的情况下并发地更新、读取同一个共享变量  

**竞态**（Race Condition）是指计算的正确性依赖于相对时间顺序或者线程的交错。根据这个定义，竞态不一定就导致计算结果的不正确，只是不排除计算结果时而正确时而错误的可能  

竞态往往伴随着读取脏数据问题，即线程读取到一个过时的数据；丢失更新问题，即一个线程对数据所做的更新没有体现在后续其他线程对该数据的读取上  

##### 竞态的两种模式：

* read-modify-write(读一改一写)模式：读取一个共享变量的值(read)，然后根据该值做一些计算(modify)，接着更新该共享变量的值(write)

* check-then-act(检测而后行动)模式：读取某个共享变量的值，根据该变量的值决定下一步的动作是什么

##### 竞态产生的条件：
设O1和O2是并发访问共享变量的两个操作，这两个操作并非都是读操作。如果一个线程在执行O1期间(开始执行而未执行结束)另外一个线程正在执行O2，那么无论O2是在读取还是更新V都会导致竞态。从这个角度来看，竞态可以被看作访问(读取、更新)同一组共享变量的多个线程所执行的操作相互交错(Interleave)，比如一个线程读取共享变量并以该共享变量为基础进行计算的期间另外一个线程更新了该共享变量的值而导致的干扰(读取脏数据)或者冲突(丢失更新)的结果  

**对于局部变量(包括形式参数和方法体内定义的变量)由于不同的线程各自访问的是各自的那一份局部变量,因此局部变量的使用不会导致竞态**

#### 线程安全
一般而言，如果一个类在单线程环境下能够运作正常，并且在多线程环境下，在其使用方不必为其做任何改变的情况下也能运作正常，那么就称其是线程安全（Thread-safe）的，相应地称这个类具有线程安全性（Thread Safety）。反之，如果一个类在单线程环境下运作正常而在多线程环境下则无法正常运作，那么这个类就是非线程安全的。因此，**一个类如果能够导致竞态，那么它就是非线程安全的；而一个类如果是线程安全的，那么它就不会导致竞态**  

使用一个类的时候必须先弄清楚这个类是否是线程安全的。Java标准库中的一些类如ArrayList、HashMap和SimpleDateFormat，都是非线程安全的，在多线程环境下直接使用它们可能导致一些非预期的结果，甚至是一些灾难性的结果。一般来说，Java标准库中的类在其API文档（JavaDoc）中会说明其是否是线程安全的（没有说明其是否是线程安全的，则可能是也可能不是线程安全的）  

如果一个线程安全的类在多线程环境下能够正常运作，那么它在单线程环境下也能正常运作。既然如此，那为什么不干脆把所有的类都做成线程安全的呢？是否将一个类做成线程安全的，从某种程度上来说是一个设计上的权衡的结果或决定：一方面，一个类是否需要是线程安全的与这个类预期被使用的方式有关，比如，一个类总是只能被一个线程独自使用，那么就没有必要将这个类做成线程安全的。其次，把一个类做成线程安全的往往是有额外代价的  

一个类如果不是线程安全的，在多线程的环境下直接使用就会存在线程安全问题。线程安全问题包括：原子性、可见性和有序性  

#### 原子性
原子(Atomic)的字面意思是不可分割的(Indivisible)对于涉及共享变量访问的操作，若该操作从其执行线程以外的任意线程来看是不可分割的，那么该操作就是原子操作，相应地就称该操作具有原子性(Atomicity)。**所谓“不可分割”，其中一个含义是指访问(读、写)某个共享变量的操作从其执行线程以外的任何线程来看,该操作要么已经执行结束要么尚未发生,即其他线程不会“看到”该操作执行了部分的中间效果**  

设O1和O2是访问共享变量V的两个原子操作，这两个操作并非都是读操作。那么一个线程执行O1期间（开始执行而未执行完毕），其他线程无法执行O2。也就是说，访问同一组共享变量的原子操作是不能够被交错的，这就排除了一个线程执行一个操作期间另外一个线程读取或者更新该操作所访问的共享变量而导致的干扰（读脏数据）和冲突（丢失更新）的可能。由此可见，**使一个操作具备原子性也就消除了这个操作导致竞态的可能性**  

理解原子操作这个概念还需要注意以下两点：

* 原子操作是针对访问共享变量的操作而言的。也就是说，仅涉及局部变量访问的操作无所谓是否是原子的，或者干脆把这一类操作都看成原子操作
* 原子操作是从该操作的执行线程以外的线程来描述的，也就是说它只有在多线程环境下有意义。换言之，单线程环境下一个操作无所谓是否具有原子性，或者干脆把这一类操作都看成原子操作

原子操作是多线程环境下的一个概念，它是针对访问共享变量的操作而言的。原子操作的“不可分割”包括以下两层含义：

* 访问（读、写）某个共享变量的操作从其执行线程以外的任何线程来看，该操作要么已经执行结束要么尚未发生，即其他线程不会“看到”该操作执行了部分的中间效果
* 访问同一组共享变量的原子操作是不能够被交错的

Java中有两种方式来实现原子性。一种是使用**锁（Lock）**。锁具有排他性，即它能够保障一个共享变量在任意一个时刻只能够被一个线程访问。这就排除了多个线程在同一时刻访问同一个共享变量而导致干扰与冲突的可能，即消除了竞态。另一种是利用处理器提供的专门**CAS（Compare-and-Swap）指令**，CAS指令实现原子性的方式与锁实现原子性的方式实质上是相同的，差别在于锁通常是在软件这一层次实现的，而CAS是直接在硬件（处理器和内存）这一层次实现的，它可以被看作“硬件锁”  

在Java语言中，long型和double型以外的任何类型的变量的写操作都是原子操作，即对基础类型（long/double除外，仅包括byte、boolean、short、char、float和int）的变量和引用型变量的写操作都是原子的。这点由Java语言规范（JLS，JavaLanguageSpecification）规定，由Java虚拟机具体实现。对long/double型变量的写操作由于Java语言规范并不保障其具有原子性，因此在多个线程并发访问同一long/double型变量的情况下，一个线程可能会读取到其他线程更新该变量的“中间结果”  

Java语言中针对任何变量的读操作都是原子操作  

从原子操作的“不可分割”特性可知，使一个操作具有原子性就可以消除该操作导致竞态的可能性。因此，可以将read-modify-write操作和check-then-act操作转换为原子操作来消除竞态。竞态模式中的read-modify-write操作本身不是原子操作，但是可以使用Java语言提供的机制使其具有原子性。竞态模式中的check-then-act操作本身不是原子操作。同样地，也可以使用与将read-modify-write操作转换为原子操作同样的方法将这种操作转换为原子操作，即使其具有原子性  

“原子操作+原子操作”所得到的复合操作并非原子操作

#### 可见性
在多线程环境下，一个线程对某个共享变量进行更新之后，后续访问该变量的线程可能无法立刻读取到这个更新的结果，甚至永远也无法读取到这个更新的结果。这就是线程安全问题的另外一个表现形式：可见性（Visibility）  

如果一个线程对某个共享变量进行更新之后，后续访问该变量的线程可以读取到该更新的结果，那么就称这个线程对该共享变量的更新对其他线程可见，否则就称这个线程对该共享变量的更新对其他线程不可见。可见性就是指一个线程对共享变量的更新的结果对于读取相应共享变量的线程而言是否可见的问题。多线程程序在可见性方面存在问题意味着某些线程读取到了旧数据（Stale Data）  

可见性问题与计算机的存储系统有关。程序中的变量可能会被分配到寄存器(Register)而不是主内存中进行存储。每个处理器都有其寄存器，而一个处理器无法读取另外一个处理器上的寄存器中的内容。因此，如果两个线程分别运行在不同的处理器上，而这两个线程所共享的变量却被分配到寄存器上进行存储，那么可见性问题就会产生。另外，即便某个共享变量是被分配到主内存中进行存储的，也不能保证该变量的可见性。这是因为处理器对主内存的访问并不是直接访问,而是通过其高速缓存(Cache)子系统进行的。一个处理器上运行的线程对变量的更新可能只是更新到该处理器的写缓冲器(Store Buffer)中，还没有到达该处理器的高速缓存中，更不用说到主内存中了。而一个处理器的写缓冲器中的内容无法被另外一个处理器读取，因此运行在另外一个处理器上的线程无法看到这个线程对某个共享变量的更新。即便一个处理器上运行的线程对共享变量的更新结果被写入该处理器的高速缓存，由于该处理器将这个变量更新的结果通知给其他处理器的时候，其他处理器可能仅仅将这个更新通知的内容存入无效化队列(Invalidate
 Queue)中，而没有直接根据更新通知的内容更新其高速缓存的相应内容，这就导致了其他处理器上运行的其他线程后续再读取相应共享变量时，从相应处理器的高速缓存中读取到的变量值是一个过时的值  

虽然一个处理器的高速缓存中的内容不能被另外一个处理器直接读取，但是处理器可以通过缓存一致性协议（Cache Coherence Protocol）来读取其他处理器的高速缓存中的数据，并将读到的数据更新到该处理器的高速缓存中。这种一个处理器从其自身处理器缓存以外的其他存储部件中读取数据并将其反映（更新）到该处理器的高速缓存的过程，称之为缓存同步。相应地，称这些存储部件的内容是可同步的，这些存储部件包括处理器的高速缓存、主内存。缓存同步使得一个处理器（上运行的线程）可以读取到另外一个处理器（上运行的线程）对共享变量所做的更新，即保障了可见性。因此，为了保障可见性，必须使一个处理器对共享变量所做的更新最终被写入该处理器的高速缓存或者主内存中（而不是始终停留在其写缓冲器中），这个过程被称为**冲刷处理器缓存**。并且，一个处理器在读取共享变量的时候，如果其他处理器在此之前已经更新了该变量，那么该处理器必须从其他处理器的高速缓存或者主内存中对相应的变量进行缓存存同步。这个过程被称为**刷新处理器缓存**。因此，可见性的硬件保障是通过使更新共享变量的处理器执行冲刷处理器缓存的动作，并使读取共享变量的处理器执行刷新处理器级存的动作来实现的  

可见性得以保障，并不意味着一个线程能够看到另外一个线程更新的所有变量的值。如果一个线程在某个时刻更新了多个共享变量的值，那么此后其他线程再来读取这些变量时，这些线程所读取到的变量值有些是其他线程更新过的值，而有些则可能仍然是其他线程更新之前的值（旧值）。对于同一个共享变量而言，一个线程更新了该变量的值之后，其他线程能够读取到这个更新后的值，那么这个值就被称为该变量的相对新值。如果读取这个共享变量的线程在读取并使用该变量的时候其他线程无法更新该变量的值，那么该线程读取到的相对新值就被称为该变量的最新值。**可见性的保障仅仅意味着一个线程能够读取到共享变量的相对新值，而不能保障该线程能够读取到相应变量的最新值**  

**Java语言规范（JLS，JavaLanguageSpecification）保证，父线程在启动子线程之前对共享变量的更新对子线程来说是可见的；Java语言规范保证，一个线程终止后该线程对共享变量的更新对于调用该线程的join方法的线程而言是可见的**  

#### 有序性
有序性（Ordering）指在什么情况下一个处理器上运行的一个线程所执行的内存访问操作在另外一个处理器上运行的其他线程看来是乱序的（Out of order）。所谓乱序，是指内存访问操作的顺序看起来像是发生了变化  

顺序结构是结构化编程中的一种基本结构，表示希望某个操作必须先于另外一个操作得以执行。另外，两个操作即便是可以用任意一种顺序执行，但是反映在代码上这两个操作也总是有先后关系。但是在多核处理器的环境下，这种操作执行顺序可能是没有保障的：编译器可能改变两个操作的先后顺序；处理器可能不是完全依照程序的目标代码所指定的顺序执行指令；另外，**一个处理器上执行的多个操作，从其他处理器的角度来看其顺序可能与目标代码所指定的顺序不一致。这种现象就叫作重排序（Reordering）**  

重排序是对内存访问有关的操作（读和写）所做的一种优化，可以在不影响单线程程序正确性的情况下提升程序的性能。但是，它可能对多线程程序的正确性产生影响，即它可能导致线程安全问题。与可见性问题类似，重排序也不是必然出现的。重排序的潜在来源有许多，包括编译器（在Java平台中基本上指JIT编译器）、处理器和存储子系统（包括写缓冲器Store Buffer、高速缓存Cache）  

* 源代码顺序（Source Code）：源代码中所指定的内存访问操作顺序
* 程序顺序（Program Order）：在给定处理器上运行的目标代码（Object Code）所指定的内存访问操作顺序。尽管Java虚拟机执行Java代码有两种方式：解释执行（被执行的是字节码ByteCode）和编译执行（被执行的是机器码）
* 执行顺序（Execution Order）：内存访问操作在给定处理器上的实际执行顺序
* 感知顺序（Perceived Order）：给定处理器所感知到的该处理器及其他处理器的内存访问操作发生的顺序

| 重排序类型 | 重排序表现 | 重排序来源（主体） |
| :----: | :----: | :----: |
| 指令重排序 | 程序顺序与源代码顺序不一致、执行顺序与程序顺序不一致 | JIT编译器、处理器 |
| 存储子系统重排序 | 源代码顺序、程序顺序和执行顺序这三者保持一致，但是感知顺序与执行顺序不一致 | 高速缓存、写缓冲器 |

##### 指令重排序
在源代码顺序与程序顺序不一致，或者程序顺序与执行顺序不一致的情况下，发生了指令重排序（Instruction Reorder）。指令重排序是一种动作，它确确实实地对指令的顺序做了调整，其重排序的对象是指令。Java平台包含两种编译器：静态编译器（javac）和动态编译器（JIT编译器）。前者的作用是将Java源代码（.java文本文件）编译为字节码（.class二进制文件），它是在代码编译阶段介入的。后者的作用是将字节码动态编译为Java虚拟机宿主机的本地代码（机器码），它是在Java程序运行过程中介入的。在Java平台中，**静态编译器（javac）基本上不会执行指令重排序，而动态编译器（JIT编译器）则可能执行指令重排序**  

处理器也可能执行指令重排序，这使得执行顺序与程序顺序不一致。处理器对指令进行重排序也被称为处理器的乱序执行（Out-of-order Execution）。现代处理器为了提高指令执行效率，往往不是按照程序顺序逐一执行指令的，而是动态调整指令的顺序，做到哪条指令就绪就先执行哪条指令，这就是处理器的乱序执行。在乱序执行的处理器中，指令是一条一条按照程序顺序被处理器读取的（亦即“顺序读取”），然后这些指令中哪条就绪了哪条就会先被执行，而不是完全按照程序顺序执行（亦即“乱序执行”）。这些指令执行的结果（要进行写寄存器或者写内存的操作）会被先存入重排序缓冲器（ROB，ReorderBuffer），而不是直接被写入寄存器或者主内存。重排序缓冲器会将各个指令的执行结果按照相应指令被处理器读取的顺序提交（Commit，即写入）到寄存器或者内存中去（亦即“顺序提交”）。在乱序执行的情况下，尽管指令的执行顺序可能没有完全依照程序顺序，但是由于指令的执行结果的提交（即反映到寄存器和内存中）仍然是按照程序顺序来的，因此处理器的指令重排序并不会对单线程程序的正确性产生影响  

**指令重排序并不会对单线程程序的正确性产生影响，但是可能导致多线程程序出现非预期的结果**

##### 存储子系统重排序
主内存（RAM）相对于处理器是一个慢速设备。为了避免其拖后腿，处理器并不是直接访问主内存，而是通过高速缓存（Cache）访问主内存的。在此基础上，现代处理器还引入了写缓冲器（Store Buffer，也称Write Buffer）以提高写高速缓存操作（以实现写主内存）的效率。将写缓冲器和高速缓存统称为存储子系统，它们其实是处理器的子系统  

即使处理器严格按照顺序执行内存访问操作，在存储子系统的作用下，其他处理器对内存访问操作的感知顺序仍然可能与程序顺序不一致。这种现象就是存储子系统重排序，也被称为内存重排序(Memory Ordering)  

指令重排序的重排序对象是指令，它实实在在地对指令的顺序进行调整，而存储子系统重排序是一种现象而不是一种动作，它并没有真正对指令执行顺序进行调整，而只是造成了一种指令的执行顺序像是被调整过一样的现象，其重排序的对象是内存操作的结果  

| 重排序类型 | 含义 |
| :----: | :----: |
| LoadLoad重排序(Loads reordered after loads) | 该重排序指一个处理器上先后执行两个读内存操作L1和L2，其他处理器对这两个内存操作的感知顺序可能是L2→L1，即L1被重排序到L2之后 |
| StoreStore重排序(Stores reordered after stores) | 该重排序指一个处理器上先后执行两个写内存操作W1和W2，其他处理器对这两个内存操作的感知顺序可能是W2→W1，即W1被重排序到W2之后 |
| LoadStore重排序(Loads reordered after stores) | 该重排序指一个处理器上先后执行读内存操作L1和写内存操作W2，其他处理器对这两个内存操作的感知顺序可能是W2→L1，即L1被重排序到W2之后 |
| StoreLoad重排序(Stores reordered after loads) | 该重排序指一个处理器上先后执行写内存操作W1和读内存操作L2，其他处理器对这两个内存操作的感知顺序可能是L2→W1，即W1被重排序到L2之后 |

**内存重排序与具体的处理器微架构有关，基于不同微架构的处理器所允许的内存重排序是不同的**  

**内存重排序可能导致线程安全问题**

##### 貌似串行语义
重排序并非随意地对指令、内存操作的结果进行杂乱无章的排序或者顺序调整，而是遵循一定的规则。编译器（主要是JIT编译器）、处理器（包括其存储子系统）都会遵守这些规则，从而给单线程程序创造一种假象（Illusion），指令是按照源代码顺序执行的。这种假象就被称为貌似串行语义（As-if-serial Semantics）。貌似串行语义只是从单线程程序的角度保证重排序后的运行结果不影响程序的正确性，它并不保证多线程环境下程序的正确性  

为了保证貌似串行语义，存在数据依赖关系的语句不会被重排序，只有不存在数据依赖关系的语句才会被重排序。如果两个操作（指令）访问同一个变量（地址），且其中一个操作（指令）为写操作，那么这两个操作之间就存在数据依赖关系（Data Dependency）  

| 类型 | 代码示例 | 说明 |
| :----: | :----: | :----: |
| 写后读（WAR） | x=1;y=x+1; | 后一条语句的操作数包含前一条语句的执行结果 |
| 读后写（RAW） | y=x;x=1; | 前一条语句读取一个变量后，后一条语句更新了该变量的值 |
| 写后写（WAW） | x=1;x=2; | 两条语句对同一变量进行写操作 |

存在控制依赖关系的语句是可以允许被重排序的。如果一条语句（指令）的执行结果会决定另外一条语句（指令）能否被执行，那么这两条语句（指令）之间就存在控制依赖关系（Control Dependency）。允许对存在控制依赖关系的语句进行重排序同样也是出于性能考虑。这是因为，存在控制依赖关系的语句（如if语句）会影响处理器对指令序列执行的并行程度  

##### 保证内存访问的顺序
硬件和软件的因素都可能导致程序的感知顺序与源代码顺序不一致，而这种不一致可能导致线程安全问题。避免重排序导致的线程安全问题实质上就是如何保证感知顺序与源代码顺序一致，即有序性  

貌似串行语义只是保障重排序不影响单线程程序的正确性。从这个角度出发，有序性的保障可以理解为通过某些措施使得貌似串行语义扩展到多线程程序，即重排序要么不发生，要么即使发生了也不会影响多线程程序的正确性。因此，有序性的保障也可以理解为从逻辑上部分禁止重排序。当然，这并不意味着从物理上禁止重排序而使得处理器完全依照源代码顺序执行指令，因为那样性能太低  

从底层的角度来说，禁止重排序是通过调用处理器提供相应的指令（内存屏障）来实现的。当然，Java作为一个跨平台的语言，它会替程序设计者与这类指令打交道，程序设计者只需要使用语言本身提供的机制即可  
#### 上下文切换

##### 上下文切换及产生的原因
时间片（Time Slice）决定了一个线程可以连续占用处理器运行的时间长度。当一个进程中的一个线程由于其时间片用完或者其自身的原因被迫或者主动暂停其运行时，另外一个线程（可能是同一个进程或者其他进程中的一个线程）可以被操作系统（线程调度器）选中占用处理器开始或者继续其运行。**这种一个线程被暂停，即被剥夺处理器的使用权，另外一个线程被选中开始或者继续运行的过程就叫作线程上下文切换**。相应地，**一个线程被剥夺处理器的使用权而被暂停运行就被称为切出（Switch Out）；一个线程被操作系统选中占用处理器开始或者继续其运行就被称为切入（Switch In）**  

实际上，看着是连续运行的线程是以断断续续运行的方式使其任务进展的。这种方式意味着在切出和切人的时候操作系统需要保存和恢复相应线程的进度信息，即切人和切出那一刻相应线程所执行的任务进行到什么程度了（如计算的中间结果以及执行到了哪条指令）。这个进度信息就被称为上下文（Context）。它一般包括通用寄存器（GeneralPurpose Register）的内容和程序计数器（Program Counter）的内容。在切出时，操作系统需要将上下文保存到内存中，以便被切出的线程稍后占用处理器继续其运行时能够在此基础上进展。在切人时，操作系统需要从内存中加载（恢复）被选中线程的上下文，以在之前运行的基础上继续进展  

**从Java应用的角度来看，一个线程的生命周期状态在RUNNABLE状态与非RUNNABLE状态（包括BLOCKED、WAITING和TIMED_WAITING中的任意一个子状态）之间切换的过程就是一个上下文切换的过程**。当一个线程的生命周期状态由RUNNABLE转换为非RUNNABLE时，就称这个线程被暂停。线程的暂停就是相应线程被切出的过程，这里操作系统会保存相应线程的上下文，以便该线程稍后再次进入RUNNABLE状态时能够在之前执行进度的基础上进展。而一个线程的生命周期状态由非RUNNABLE状态进人RUNNABLE状态时，就称这个线程被唤醒（Wakeup）。**一个线程被唤醒仅代表该线程获得了一个继续运行的机会，而并不代表其立刻可以占用处理器运行**。因此，当被唤醒的线程被操作系统选中占用处理器继续其运行的时候，操作系统会恢复之前为该线程保存的上下文，以便其在此基础上进展  

##### 上下文切换的分类及诱因
按照导致上下文切换的因素划分，可以将上下文切换分为自发性上下文切换（Voluntary Context Switch）和非自发性上下文切换（Involuntary Context Switch ）。
自发性上下文切换指线程由于其自身因素导致的切出。从Java平台的角度来看，一个线程在其运行过程中执行下列任意一个方法都会引起自发性上下文切换：

* Thread.sleep(long millis)
* Object.wait()/wait(long timeout)/wait(long timeout, int nanos)
* Thread.yield()
* Thread.join()/Thread.join(long timeout)
* LockSupport.park()

另外，线程发起了I/O操作或者等待其他线程持有的锁也会导致自发性上下文切换  

非自发性上下文切换指线程由于线程调度器的原因被迫切出。导致非自发性上下文切换的常见因素包括被切出线程的时间片用完或者有一个比被切出线程优先级更高的线程需要被运行。从Java平台的角度来看，Java虚拟机的垃圾回收（Garbage Collect）动作也可能导致非自发性上下文切换。这是因为垃圾回收器在执行垃圾回收的过程中可能需要暂停所有应用线程（Stop-the-world）才能完成其工作，比如在主要回收（Major Collection）过程中，垃圾回收器在对Java虚拟机堆内存区域进行整理（Compact）的时候需要先停止所有应用线程  

##### 上下文切换的开销及测量
从定性的角度来说，上下文切换的开销包括直接开销和间接开销。其中，直接开销包括：

* 操作系统保存和恢复上下文所需的开销，这主要是处理器时间开销
* 线程调度器进行线程调度的开销

间接开销包括：

* 处理器高速缓存重新加载的开销。一个被切出的线程可能稍后在另外一个处理器上被切入继续运行。由于这个处理器之前可能未运行过该线程，那么这个线程在其继续运行过程中需访问的变量仍然需要被该处理器重新从主内存或者通过缓存一致性协议从其他处理器加载到高速缓存之中。这是有一定时间消耗的
* 上下文切换也可能导致整个一级高速缓存中的内容被冲刷（Flush），即一级高速缓存中的内容会被写入下一级高速缓存（如二级高速缓存）或者主内存（RAM）中

从定量的角度来说，一次上下文切换的时间消耗是微秒级的

#### 线程的活性故障
**由资源稀缺性或者程序自身的问题和缺陷导致线程一直处于非RUNNABLE状态，或者线程虽然处于RUNNABLE状态但是其要执行的任务却一直无法进展的现象就被称为线程活性故障（Liveness Failure）**  

常见的活性故障包括以下几种：

* 死锁（Deadlock）。死锁的外在表现是当事线程的生命周期状态永远处于非RUNNABLE状态而使其任务一直无法进展
* 锁死（Lockout）
* 活锁（Livelock）。活锁的外在表现是线程可能处于RUNNABLE状态，但是线程所要执行的任务却丝毫没有进展，即线程可能一直在做无用功
* 饥饿（Starvation）。饥饿就是线程因无法获得其所需的资源而使得任务执行无法进展的现象

#### 资源争用与调度
由于资源的稀缺性或者资源本身的特性，往往需要在多个线程间共享同一个资源。一次只能够被一个线程占用的资源被称为排他性（Exclusive）资源。常见的排他性资源包括处理器、数据库连接、文件等。在一个线程占用一个排他性资源进行访问（读、写操作）而未释放其对资源所有权的时候，其他线程试图访问该资源的现象就被称为资源争用（ResourceContention），简称争用。显然，争用是在并发环境下产生的一种现象。同时试图访问同一个已经被其他线程占用的资源的线程数量越多，争用的程度就越高；反之争用的程度就越低。相应的争用就被分别称为高争用和低争用  

约定同一时间内，处于运行状态（即生命周期状态为RUNNABLE的RUNNING子状态的线程）的线程数量越多，就称并发的程度越高，简称高并发，高并发是相对于低并发而言的。虽然高并发增加了争用的概率，但是高并发未必意味着高争用  

当多个线程共享同一个资源又会带来新的问题，即资源的调度问题。在多个线程申请同一个排他性资源的情况下，决定哪个线程会被授予该资源的独占权，即选择哪个申请者占用该资源的过程就是资源的调度。获得资源的独占权而又未释放其独占权的线程就被称为该资源的持有线程。资源调度策略的一个常见特性就是它能否保证公平性。所谓公平性（Fairness），是指资源的申请者（线程）是否按照其申请（请求）资源的顺序而被授予资源的独占权。如果资源的任何一个先申请者总是能够比任何一个后申请者先获得该资源的独占权，那么相应的资源调度策略就被称为是公平的（Fair）；如果资源的后申请者可能比先申请者先获得该资源的独占权，那么相应的资源调度策略就被称为是非公平的（Non-fair）。需要注意的是，非公平的资源调度策略往往只是说明它并不保证资源调度的公平性，即它允许不公平的资源调度的出现，而不是表示它刻意造就不公平（Unfair）的资源调度  

资源调度的一种常见策略就是排队。资源调度器（负责资源调度）内部维护一个等待队列，在存在资源争用的情况下，申请失败（即没有获得资源的独占权）的资源申请者（线程）会被存入该队列。通常，被存入等待队列的线程会被暂停。当相应的资源被其持有线程释放时，等待队列中的一个线程会被选中并被唤醒而获得再次申请资源的机会。被唤醒的线程如果申请到资源的独占权，那么该线程会从等待队列中移除；否则，该线程仍然会停留在等待队列中等待再次申请的机会，即该线程会再次被暂停。因此，等待队列中的等待线程可能经历若干次暂停与唤醒才获得相应资源的独占权。可见，资源的调度可能导致上下文切换  

从排队的角度来看，公平的调度策略不允许插队现象的出现，即只有在资源未被其他任何线程占用，并且等待队列为空（没有其他等待再次获得资源申请机会的线程）的情况下，资源的申请者才被允许抢占相应资源的独占权。其中，抢占成功的申请者获得相应资源的独占权，而抢占失败的申请者会进入等待队列。因此，公平调度策略中的资源申请者总是按照先来后到的顺序来获得资源的独占权。而非公平的调度策略则允许插队现象，即一个线程释放其资源独占权的时候，等待队列中的一个线程会被唤醒再次申请相应的资源，而在这个过程中另外一个申请该资源的活跃线程（生命周期状态为RUNNABLE状态）可以与这个被唤醒的线程共同参与相应资源的抢占。因此，非公平调度策略中被唤醒的线程不一定就能够成功申请到资源。由此可见，在极端的情况下非公平调度策略可能导致等待队列中的线程永远无法获得其所需的资源，即出现饥饿（Starvation）现象，而公平调度策略则可以避免饥饿现象  

一般来说，非公平调度策略的乔吐率较高，即单位时间内它可以为更多的申请者调配资源。其缺点是，从申请者个体的角度来看这些申请者获得相应资源的独占权所需时间的偏差可能比较大，即有的线程很快就申请到资源而有的线程则要经历若干次暂停与唤醒オ成功申请到资源。公平调度策略的吞吐率较低，这是其维护资源独占权的授予顺序的开销比较大（主要是线程的暂停与唤醒所导致的上下文切换）的结果。其优点是，从申请者个体的角度来看这些申请者获得相应资源的独占权所需时间的偏差可能比较小，即每个申请者成功申请到资源所需的时间基本相同。在非公平调度策略中，资源的持有线程释放该资源的时候等待队列中的一个线程会被唤醒，而该线程从被唤醒到其继续运行可能需要一段时间。在该时间内，新来的线程（活跃线程）可以先被授予该资源的独占权。如果这个新来的线程占用该资源的时间不长，那么它完全有可能在被唤醒的线程继续其运行前释放相应的资源，从而不影响该被唤醒的线程申请资源。这种情形下，非公平调度策略带来一个好处一它可能减少上下文切换的次数（例如，前面例子中新来的线程无须被暂停和唤醒就申请到资源）。相反，如果多数（或者每个）线程占用资源的时间相当长，那么允许新来的线程抢先占用被释放的资源丝毫不会带来任何好处，反而会导致被唤醒的线程需要再次经历暂停和唤醒，从而增加了上下文切换。因此，多数（或者每个）线程占用资源的时间相当长（或者申请资源的间隔相对长）的情况下不适合使用非公平调度策略。因此，在没有特别需要的情况下，默认选择非公平调度策略即可。在资源的持有线程占用资源的时间相对长或线程申请资源的平均间隔时间相对长的情况下，或者对资源申请所需的时间偏差有所要求（即时间偏差较小）的情况下，可以考虑使用公平调度策略

非公平调度策略是多数情况下的首选资源调度策略。其优点是吞吐率较大；缺点是资源申请者申请资源所需的时间偏差可能较大，并可能导致饥饿现象。公平调度策略适合在资源的持有线程占用资源的时间相对长或资源的平均申请时间间隔相对长的情况下，或者对资源申请所需的时间偏差有所要求的情况下使用。其优点是线程申请资源所需的时间偏差较小，并且不会导致饥饿现象；其缺点是吞吐率较小

### Java线程同步机制
https://www.cnblogs.com/huansky/p/8869888.html
https://baike.baidu.com/item/synchronized/8483356?fr=aladdin
https://zhuanlan.zhihu.com/p/85584752
https://blog.csdn.net/qq_16669583/article/details/90671418

https://blog.csdn.net/mynote/article/details/38070347
https://www.cnblogs.com/nulisaonian/p/6076674.html

https://www.jianshu.com/p/f50455ad3514
https://www.imooc.com/article/34476
https://baike.baidu.com/item/%E5%A0%86%E6%A0%88/1682032?fr=aladdin

https://www.cnblogs.com/leiblog/p/10605798.html

https://www.h3399.cn/201804/569993.html


https://www.cnblogs.com/wcgstudy/p/11795886.html

### 线程管理

#### 线程工厂

从JDK1.5开始，Java标准库本身就支持创建线程的工厂方法(Factory Method)。ThreadFactory接口是工厂方法模式的一个实例，它定义了如下工厂方法:

```
public Thread newThread (Runnable r)
```

newThread方法可以用来创建线程，该方法的参数r代表所创建的线程需要执行的任务。如果把线程对象看作某种“产品”，那么通过new方式创建线程就好比手工制作，而使用ThreadFactory接口创建线程则好比是工厂采用标准化的流水线进行生产。我们可以在ThreadFactory.newThread方法中封装线程创建的逻辑，这使得我们能够以统一的方式为线程的创建、配置做-些非常有用的动作

```
import java.util.concurrent.ThreadFactory;

public class XThreadFactory implements ThreadFactory {
    // 所创建的线程的线程名前缀
    private final String namePrefix;

    public XThreadFactory(String name) {
        this.namePrefix = name;
    }

    protected Thread doMakeThread(final Runnable r) {
        return new Thread(r) {
            @Override
            public void run() {
                System.out.println("this is a thread");
            }
        };
    }

    @Override
    public Thread newThread(Runnable r) {
        Thread t = doMakeThread(r);
        t.setName(namePrefix);
        if (t.isDaemon()) {
            t.setDaemon(false);
        }
        if (t.getPriority() != Thread.NORM_PRIORITY) {
            t.setPriority(Thread.NORM_PRIORITY);
        }
        return t;
    }

}
```

#### 线程池

线程是一种昂贵的资源，其开销主要包括以下几个方面

* 线程的创建与启动的开销。与普通的对象相比，Java线程还占用了额外的存储空间：栈空间。并且，线程的启动会产生相应的线程调度开销
* 线程的销毁。线程的销毁也有其开销
* 线程调度的开销。线程的调度会导致上下文切换，从而增加处理器资源的消耗，使得应用程序本身可以使用的处理器资源减少
* 一个系统能够创建的线程总是受限于该系统所拥有的处理器数目。无论是CPU密集型还是I/O密集型线程，这些线程的数量的临界值总是处理器的数目

因此，从整个系统的角度来看我们需要一种有效使用线程的方式。线程池就是有效使用线程的一种常见方式

线程池内部可以预先创建一定数量的工作者线程，客户端代码将其需要执行的任务作为一个对象提交给线程池，线程池可能将这些任务缓存在队列(工作队列)之中，而线程池内部的各个工作者线程则不断地从队列中取出任务并执行。因此，线程池可以被看作基于生产者-消费者模式的一种服务，该服务内部维护的工作者线程相当于消费者线程，线程池的客户端线程相当于生产者线程，客户端代码提交给线程池的任务相当于“产品”，线程池内部用于缓存任务的队列相当于传输通道

java.util.concurrent.ThreadPoolExecutor类就是一个线程池，客户端代码可以调用ThreadPoolExecutor.submit方法向其提交任务，ThreadPoolExecutor.submit方法声明如下:

```
public Future<?> submit (Runnable task)
```

其中，task参数是一个Runnable实例，它代表客户端需要线程池代为执行的任务

线程池内部维护的工作者线程的数量就被称为该线程池的线程池大小(PoolSize)。ThreadPoolExecutor的线程池大小有3种形态:当前线程池大小(Current Pool Size)表示线程池中实际工作者线程的数量;最大线程池大小(Maximum Pool Size)表示线程池中允许存在的工作者线程的数量上限;核心线程大小(Core Pool Size)表示一个不大于最大线程池大小的工作者线程数量上限。它们之间的数量关系如下:

* 当前线程池大小≤核心线程池大小≤最大线程池大小

或

* 核心线程池大小≤当前线程池大小≤最大线程池大小

除了当前线程池大小是对线程池中现有的工作者线程进行计数的结果，其他有关线程池大小的概念实际上都是由开发人员或者系统配置数据指定的一个阈值(Threshold)

ThreadPoolExecutor的构造器中包含参数数量最多的一个构造器的声明如下:

```
public ThreadPoolExecutor (int corePoolSize,
                           int maximumPoolSize,
                           long keepAliveTime,
                           TimeUnit unit,
                           BlockingQueue <Runnable> workQueue,
                           ThreadFactory threadFactory,
                           RejectedExecutionHandler handler)
```

其中，workQueue是被称为工作队列的阻塞队列，它相当于生产者-消费者模式中的传输通道，corePoolSize用于指定线程池核心大小，maximumPoolSize用于指定最大线程池大小。keepAliveTime和unit合在一起用于指定线程池中空闲(Idle)线程的最大存活时间。threadFactory指定用于创建工作者线程的线程工厂

**corePoolSize是线程池活跃的线程数量，keepAliveTime参数只有线程数量超过corePoolSize起作用**

在初始状态下，客户端每提交个任务线程池就创建一个工作者线程来处理该任务。随着客户端不断地提交任务，当前线程池大小也相应增加。在当前线程池大小达到核心线程池大小的时候，新来的任务会被存入工作队列之中。这些缓存的任务由线程池中的所有工作者线程负责取出进行执行。线程池将任务存入工作队列的时候调用的是BlockingQueue的非阻塞方法offer(E e),因此工作队列满并不会使提交任务的客户端线程
暂停。当工作队列满的时候，线程池会继续创建新的工作者线程，直到当前线程池大小达到最大线程池大小。线程池是通过调用threadFactory.newThread方法来创建工作者线程的。如果我们在创建线程池的时候没有指定线程工厂(即调用了ThreadPoolExecutor的其他构造器)，那么ThreadPoolExecutor会使用Executors.defaultThreadFactory)所返回的默认线程工厂。当线程池饱和(Saturated)时，即工作者队列满并且当前线程池大小达到最大线程池大小的情况下，客户端试图提交的任务会被拒绝(Reject)。为了提高线程池的可靠性，Java标准库引人了一个RejectedExecutionHandler接口用于封装被拒绝的任务的处理策略，该接口仅定义了如下方法:

```
void rejectedExecution (Runnable r, ThreadPoolExecutor executor)
```

其中，r代表被拒绝的任务，executor代表拒绝任务r的线程池实例。我们可以通过线程池的构造器参数handler或者线程池的setRejectedExecutionHandler(RejectedExecutionHandlerhandler)方法来为线程池关联一个RejectedExecutionHandler。当客户端提交的任务被拒绝时，线程池所关联的RejectedExecutionHandler的rejectedExecution方法会破线程池调用。ThreadPoolExecutor 自身提供了几个现成的RejectedExecutionHandler接口，其中ThreadPoolExecutor.AbortPolicy是ThreadPoolExecutor使用的默认RejectedExecutionHandler。如果默认的RejectedExecutionHandler(它会直接抛出异常)无法满足要求，那么我们可以优先考虑ThreadPoolExecutor自身提供的其他RejectedExecutionHandler，其次才去考虑使用自行实现的RejectedExecutionHandler接口

在当前线程池大小超过线程池核心大小的时候，超过线程池核心大小部分的工作者线程空闲(即工作者队列中没有待处理的任务)时间达到keepAliveTime所指定的时间后就会被清理掉，即这些工作者线程会自动终止并被从线程池中移除。这种空闲线程清理机制有利于节约有限的线程资源，但是keepAliveTime值设置不合理( 特别是设置得太小)可能导致工作者线程频繁地被清理和创建反而增加了开销

线程池中数量上等于核心线程池大小的那部分工作者线程、习惯上我们称之为核心线程(Core Thread)。当前线程池大小是随着线程池接收到的任务的数量而逐渐向核心线程池大小靠拢的，即核心线程是逐渐被创建与启动的。ThreadPoolExecutor.prestartAllCoreThreads()则使得我们可以使线程池在未接收到任何任务的情况下预先创建并启动所有核心线程，这样可以减少任务被线程池处理时所需的等待时间(等待核心线程的创建与启动)

ThreadPoolExecutor.shutdown()/shutdownNow()方法可用来关闭线程池。使用shutdown()关闭线程池的时候，已提交的任务会被继续执行，而新提交的任务会像线程池饱和时那样被拒绝掉。ThreadPoolExecutor.shutdown()返回的时候线程池可能尚未关闭，即线程池中可能还有工作者线程正在执行任务。应用代码可以通过调用ThreadPoolExcutor.awaitTermination(long timeout,TimeUnit unit)来等待线程池关闭结束。使用ThreadPoolExecutor.shutdownNow()关闭线程池的时候，正在执行的任务会被停止，已提交而等待执行的任务也不会被执行。该方法的返回值是已提交而未被执行的任务列表，这为被取消的任务的重试提供了一个机会。由于ThreadPoolExecutor.shutdownNow()内部是通过调用工作者线程的interrupt方法来停止正在执行的任务的，因此某些无法响应中断的任务可能永远也不会停止。反过来说，在关闭线程池的时候如果我们能够确保已经提交的任务都已执行完毕并且没有新的任务会被提交，那么调用ThreadPoolExecutor.shutdownNow()总是安全可靠的

由于线程池(消费者)通常需要接收来自不同客户端(生产者)线程所提交的任务，因此一般情况下我们会以实例变量(或者静态变量)的形式来存储ThreadPoolExecutor实例



## 异步编程

#### 同步计算和异步计算

从多个任务的角度来看，任务可以是串行执行的，也可以是并发执行的。从单个任务的角度来看，任务的执行方式可以是同步的(Synchronous)，也可以是异步的(Asynchronous)

以同步方式执行的任务，称之为同步任务，其任务的发起与任务的执行是在同一条时间线上进行的。换而言之，任务的发起与任务的执行是串行的

以异步方式执行的任务，称之为异步任务，其任务的发起与任务的执行是在不同的时间线上进行的。换而言之，任务的发起与任务的执行是并发的

同步方式与异步方式的说法是相对的：同一个任务既可以说是异步任务，也可以说是同步任务

假设用一个Runnable实例task来表示一个任务，如果直接调用task.run()来执行该任务，那么就可以称该任务为同步任务;如果通过new Thread(task).start()调用创建并启动一个专门的工作者线程来执行该任务，或者将该任务提交给一个Executor实例executor执行(即调用executor.execute(task)),那么就可以称该任务为异步任务

同步方式与异步方式的称呼不仅仅取决于一个任务的具体执行方式，还取决于观察的角度。假设将task提交给线程池执行，那么从该任务提交线程(即ThreadPoolExecutor.submit方法的执行线程)的角度来看它是一个异步任务，而从线程池中的工作者线程(即实际执行该任务的线程)的角度来看该任务则可能是一个同步任务

同步任务的发起线程在其发起该任务之后必须等待该任务执行结束才能够执行其他操作，这种等待往往意味着阻塞(Blocking)，即任务的发起线程会被暂停，直到任务执行结束;同步任务也并不一定总是会使其发起线程被阻塞，同步任务的发起线程也可能以轮询的方式来等待任务的结束。所谓轮询(Polling)是指任务的发起线程不断地检查其发起的任务是否执行结束，若任务已执行结束则执行下一步操作，否则继续检查任务，直到该任务完成。阻塞意味着在同步任务执行结束前，该任务的发起线程并没有在运行(其生命周期状态不为RUNNABLE)，而轮询意味着在同步任务执行结束前，该任务的发起线程仍然在运行，只不过此时该线程的主要动作是检查相应的任务是否执行结束。同步任务的发起线程是采用阻塞的方式还是轮询方式来等待任务的结束很大程度上取决于使用的API。例如，使用java.nio.channels.Selctor类来编写网络应用程序的服务端代码的时，我们能够采用轮询的方式来实现等待同步任务的结束，而多数情况下只能够以阻塞方式来实现等待同步任务的结束。单个线程便可以实现同步任务的执行。在使用单个线程的情况下，多个同步任务只能够以同步的方式执行

异步任务的发起线程在其发起该任务之后不必等待该任务结束便可以继续执行其他操作，即异步任务的发起与实际执行可以是并发的。**多线程编程本质上是异步的**。比如一个线程通过ThreadPoolExecutor.submit(Callable<T>)调用向线程池提交一个任务(任务的发起)，在该调用返回之后该线程便可以执行其他操作了，而该任务可能在此之后才被线程池中的某一个工作者线程所执行，这里任务的提交与执行是并发的，而不是串行的。可见，异步任务可以使其发起线程不必因等待其执行结束而被阻塞，即异步任务执行方式往往意味着非阻塞(Non-blocking)。然而，阻塞与非阻塞只是任务执行方式的一种属性，它与任务执行方式之间并没有必然的关系:同步任务执行方式多数情况下意味着阻塞，但是它也可能意味着非阻塞(轮询);异步任务执行方式多数情况下意味着非阻塞，但是它也可能意味着阻塞。例如，如果在向线程池提交一个任务之后立刻调用Future.get()来试图获取该任务的处理结果(即ThreadPoolExecutor.submit(someTask).get())，那么尽管该任务是异步执行的，但是其发起线程仍然可能由于Future.get()调用时该任务尚未被线程池执行结束而被阻塞。异步任务的执行需要借助多个线程来实现。多个异步任务能够以并发的方式被执行

**阻塞与非阻塞只是任务执行方式(同步/异步)本身的一种属性，它们与任务执行方式之间并未有必然的联系:异步任务既可能是非阻塞的，也可能是阻塞的;同步任务既可能是阻塞的，也可能是非阻塞的。
同步方式与异步方式的说法是相对的，它取决于任务的执行方式以及观察的角度**

**同步方式的优点是代码简单、直观，缺点是它往往意味着阻塞，而阻塞会限制系统的吞吐率。异步方式往往意味着非阻塞，因而有利于提高系统的吞吐率。异步方式的代价是更为复杂的代码和更多的资源投入。例如，以异步方式执行任务需要借助额外的工作者线程，并且还需要对这些工作者线程进行管理(启动、停止等)**

#### 使用线程实现异步

```
    public static void doSomethingA() {
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("--- doSomethingA---");
    }
    public static void doSomethingB() {
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("--- doSomethingB---");
    }
    public static void main(String[] args) throws InterruptedException {
        long start = System.currentTimeMillis();
        // 1.开启异步单元执行任务A
        Thread thread = new Thread(() -> {
            try {
                doSomethingA();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }, "threadA");
        thread.start();
        // 2.执行任务B
        doSomethingB();
        // 3.同步等待线程A运行结束
        thread.join();
        System.out.println(System.currentTimeMillis() - start);
    }
```

#### Java Executor框架

Runnable接口和Callable接口都是对任务处理逻辑的抽象，这种抽象使得我们无须关心任务的具体处理逻辑:不管是什么样的任务，其处理逻辑总是展现为一个具有统一签名的方法:Runnable.run()或者Callable.call()

java.util.concurrentExecutor接口则是对任务的执行进行的抽象，该接口仅定义了如下方法:

```
void execute(Runnable command)
```

其中，command参数代表需要执行的任务。Executor接口使得任务的提交方(相当于生产者)只需要知道它调用Executor.execute方法便可以使指定的任务被执行，而无须关心任务具体的执行细节:比如，任务是采用一个专门的工作者线程执行的，还是采用线程池执行的;采用什么样的线程池执行的;多个任务是以何种顺序被执行的。可见，Executor接口使得任务的提交能够与任务执行的具体细节解耦(Decoupling)

解耦任务的提交与任务的具体执行细节所带来的好处的一个例子是，它在一定程度上能够屏蔽任务同步执行与异步执行的差异。例如，对于同一个任务(Runnable实例)，如果我们把它提交给一个ThreadPoolExecutor(它实现了Executor接口)执行，那么该任务就是异步执行;如果把这个任务提交给如下代码所示的Executor实例执行，那么该任务就是同步执行

```
public class SynchronousExecutor implements Executor {
    @Override
    public void execute (Runnable command) {
        command.run();
    }
}
```

这个任务不管是同步执行还是异步执行，对于其提交方来说并没有太大差别，这就为更改任务的具体执行方式提供了灵活性和便利:更改任务的具体执行细节可能不会影响到任务的提交方，而这意味着更小的代码改动量和测试量

可见，Executor接口定程度上缩小了同步编程与异步编程的代码编写方式。Executor接口比较简单，功能也十分有限:首先，它只能为客户端代码执行任务，而无法将任务的处理结果返回给客户端代码;其次，Executor接口实现类内部往往会维护一些工作者线程，当我们不再需要一个Executor实例的时候，往往需要主动将该实例内部维护的工作者线程停掉以释放相应的资源，而Executor接口并没有定义相应的方法

ExecutorService接口继承自Executor接口，它解决了上述问题。ExecutorService接口定义了几个submit方法，这些方法能够接受Callable接口或者Runnable接口表示的任务并返回相应的Future实例，从而使客户端代码提交任务后可以获取任务的执行结果。ExecutorService接口还定义了shutdown()方法和shutdownNow()方法来关闭相应的服务(比如关闭其维护的工作者线程)。ThreadPoolExecutor是ExecutorService的默认实现类

#### 使用线程池实现异步

```
    public static void doSomethingA() {
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("--- doSomethingA---");
    }
    public static void doSomethingB() {
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("--- doSomethingB---");
    }
    private final static int AVAILABLE_PROCESSORS =
            Runtime.getRuntime().availableProcessors(); 
    private final static
    ThreadPoolExecutor POOL_EXECUTOR = new ThreadPoolExecutor(AVAILABLE_PROCESSORS,
            AVAILABLE_PROCESSORS * 2, 1, TimeUnit.MINUTES, new LinkedBlockingQueue<>(5), new
            ThreadPoolExecutor.CallerRunsPolicy());
    public static void main(String[] args) throws InterruptedException,
            ExecutionException {
        long start = System.currentTimeMillis();
        // 1.开启异步单元执行任务A
        POOL_EXECUTOR.execute(() -> {
            try {
                doSomethingA();
            } catch (Exception e) {
                e.printStackTrace(); }
        });
        // 2.执行任务B
        POOL_EXECUTOR.execute(() -> {
            try {
                doSomethingB();
            } catch (Exception e) {
                e.printStackTrace(); }
        });
        // 3.同步等待线程A运行结束
        System.out.println(System.currentTimeMillis() - start);
        // 4.挂起当前线程
        Thread.currentThread().join();
    }
```

#### 使用Future获取异步执行结果

如果关心任务的处理结果，那么可以使用ThreadPoolExecutor的另外一个submit方法来提交任务，该submit方法的声明如下:

```
public Future<?> submit(Runnable task)
public <T> Future<T> submit (Callable<T> task)
public <T> Future<T> submit(Runnable task, T result)
```

Callable接口也是对任务的抽象:任务的处理逻辑可以在Callable接口实现类的call方法中实现。Callable接口相当于一个增强型的Runnable接口:call方法的返回值代表相应任务的处理结果，其类型V是通过Callable接口的类型参数指定的;call方法代表的任务在其执行过程中可以抛出异常。而Runnable接口中的run方法既无返回值也不能抛出异常。Executors.callable(Runnable task,T result)能够将Runnable接口转换为Callable接口实例

submit方法的返回值类型为java.util.concurrent.Future。Future接口实例可被看作提交给线程池执行的任务的处理结果句柄(Handle)，Future.get()方法可以用来获取task参数所指定的任务的处理结果

##### Future

在Java并发包（JUC包）中Future代表着异步计算结果，Future中提供了一系列方法用来检查计算结果是否已经完成，也提供了同步等待任务执行完成的方法，还提供了获取计算结果的方法等。当计结果完成时只能通过提供的get系列方法来获取结果，如果使用了不带超时时间的get方法，则在计算结果完成前，调用线程会被一直阻塞

```
    public static String doSomethingA() {
        try {
            Thread.sleep(2000); } catch (InterruptedException e) {
            e.printStackTrace(); }
        System.out.println("--- doSomethingA---"); return "A Task Done";
    }
    // 自定义线程池
    private final static int AVALIABLE_PROCESSORS =
            Runtime.getRuntime().availableProcessors();
    private final static
    ThreadPoolExecutor POOL_EXECUTOR = new ThreadPoolExecutor(AVALIABLE_PROCESSORS,
            AVALIABLE_PROCESSORS * 2, 1, TimeUnit.MINUTES, new LinkedBlockingQueue<>(5), new ThreadPoolExecutor.CallerRunsPolicy());
    public static void main(String[] args) throws InterruptedException,
            ExecutionException {
        // 1.开启异步单元执行任务A
        Future<?> resultA = POOL_EXECUTOR.submit(() -> doSomethingA());
        // 2.同步等待执行结果
        System.out.println(resultA.get());
    }
```

Future.get()被调用时，如果相应的任务尚未执行完毕，那么Future.get()会使当前线程暂停，直到相应的任务执行结束(包括正常结束和抛出异常而终止)。因此，Future.get()是个阻塞方法，该方法能够抛出InterruptedException说明它可以响应线程中断。由于在任务未执行完毕的情况下调用Future.get()方法来获取该任务的处理结果会导致等待并由此导致上下文切换，因此客户端代码应该尽可能早地向线程池提交任务，并尽可能晚地调用Future.get()方法来获取任务的处理结果，而线程池则正好利用这段时间来执行已提交的任务(包括我们关心的任务)

##### CompletionService

尽管Future接口使得我们能够方便地获取异步任务的处理结果，但是如果需要一次性提交一批异步任务并获取这些任务的处理结果的话，那么仅使用Future接口写出来的代码将颇为烦琐。java.util.concurrent.CompletionService接口为异步任务的批量提交以及获取这些任务的处理结果提供了便利

CompletionService接口定义的一个submit方法可用于提交异步任务，该方法的签名与ThreadPoolExecutor的submit方法相同：

```
Future<V> submit (Callable<V> task)
```

task参数代表待执行的异步任务，该方法的返回值可用于获取相应异步任务的处理结果。如果是批量提交异步任务，那么通常我们并不关心该方法的返回值。若要获取批量提交的异步任务的处理结果，那么我们可以使用CompletionService接口专门为此定义的方法，其中的一个方法是:

```
Future<v> take () throws InterruptedException
```

该方法与BlockingQueue.take()相似，它是一个阻塞方法，其返回值是一个已经执行结束的异步任务对应的Future实例，该实例就是提交相应任务时submit(Callable<V>)调用的返回值。如果take()被调用时没有已执行结束的异步任务，那么take()的执行线程就会被暂停，直到有异步任务执行结束。因此，我们批量提交了多少个异步任务，则多少次连续调用CompletionService.take()便可以获取这些任务的处理结果

CompletionService也定义了两个非阻塞方法用于获取异步任务的处理结果:

```
Future<V> poll ()
Future<V> poll (long timeout, TimeUnit unit) throws InterruptedException
```

这两个方法与BlockingQueue的poll方法相似，它们的返回值是已执行结束的异步任务对应的Future实例

Java标准库提供的CompletionService接口的实现类是ExecutorCompletionService.ExecutorCompletionService的一个构造器是: 

```
ExecutorCompletionService (Executor executor, BlockingQueue<Future<V>> completionQueue)
```

由此可见，ExecutorCompletionService相当于Executor实例与BlockingQueue实例的一个融合体。其中，Executor实例负责接收并执行异步任务，而BlockingQueue实例则用于存储已执行完毕的异步任务对应的Future实例。ExecutorCompletionService会为其客户端提交的每个异步任务(Callable实例或者Runnable实例)都创建一个相应的Future实例，通过该实例其客户端代码便可以获取相应异步任务的处理结果。ExecutorCompletionService每执行完-个异步任务，就将该任务对应的Future实例存人其内部维护的BlockingQueue实例之中，而其客户端代码则可以通过ExecutorCompletionService.take()调用来获取这个Future实例

使用ExecutorCompletionService的另一个构造器ExecutorCompletionService(Executor executor)创建实例相当于: 

```
new ExecutorCompletionService<v> (executor,new LinkedBlockingQueue<Future<v>> ());
```

ExecutorService.invokeAll(Collection<? extends Callable<T>> tasks)也能够用来批量提交异步任务，该方法能够并发执行tasks参数所指定的一批任务，但是该方法只有在tasks参数所指定的一批任务中的所有任务都执行结束之后才返回，其返回值是一个包含各个任务对应的Future实例的列表(List)。因此，使用invokeAll方法提交批量任务的时候，任务提交方等待invokeAll方法返回的时间取决于这批任务中最耗时的任务的执行耗时

##### FutureTask

无论是Runnable实例还是Callable实例所表示的任务，只要我们将其提交给线程池执行，那么这些任务就是异步任务。采用Runnable实例来表示异步任务，其优点是任务既可以交给一个专门的工作者线程执行(以相应的Runnable实例为参数创建并启动个工作者线程),也可以交给一个线程池或者Executor的其他实现类来执行;其缺点是我们无法直接获取任务的执行结果。使用Callable实例来表示异步任务，其优点是我们可以通过ThreadPoolExecutor.submit(Callable<T>)的返回值获取任务的处理结果;其缺点是Callable实例表示的异步任务只能交给线程池执行，而无法直接交给一个专门的工作者线程或者Executor实现类执行。因此，使用Callable实例来表示异步任务会使任务执行方式的灵活性大为受限

java.util.concurrent.FutureTask类则融合了Runnable接口和Callable接口的优点:FutureTask是Runnable接口的一个实现类，因此FutureTask表示的异步任务可以交给专门的工作者线程执行，也可以交给Executor实例(比如线程池)执行;FutureTask还能够直接返回其代表的异步任务的处理结果。ThreadPoolExecutor.submit(Callable<T> task)的返回值就是一个FutureTask实例。FutureTask是java.util.concurrent.RunnableFuture接口的一个实现类。由于RunnableFuture接口继承了Future接口和Runnable接口，因此FutureTask既是Runnable接口的实现类也是Future接口的实现。FutureTask的一个构造器可以将Callable实例转换为Runnable实例，该构造器的声明如下:

```
public FutureTask (Callable<V> callable)
```

该构造器使得我们能够方便地创建一个能够返回处理结果的异步任务。我们可以将任务的处理逻辑封装在一个Callable实例中，并以该实例为参数创建一个FutureTask实例。由于FutureTask类实现了Runnable接口，因此上述构造器的作用就相当于将Callable实例转换为Runnable实例，而FutureTask实例本身也代表了我们要执行的任务。我们可以用FutureTask实例(Runnable实例)为参数来创建并启动一个工作者线程以执行相应的任务，也可以将FutureTask实例交给Executor执行(通过Executor.execute(Runnable task)调用)。FutureTask类还实现了Future接口，这使得我们在调用Executor.execute(Runnable task)这样只认Runnable接口的方法来执行任务的情况下依然能够获取任务的执行结果:一个工作者线程(可以是线程池中的一个工作者线程)负责调用FutureTask.run()执行相应的任务，另外一个线程则调用FutureTask.get()来获取任务的执行结果。因此，FutureTask实例可被看作一个异步任务，它使得任务的执行和对任务执行结果的处理得以并发执行，从而有利于提高系统的并发性

ThreadPoolExecutor.submit(Callable<T> task)方法继承自AbstractExecutorService.submit(Callable<T> task)。AbstractExecutorService.submit(Callable<T> task)内部实现就是借助FutureTask的。submit方法会根据指定的Callable实例task创建一个FutureTask实例ftask，并通过Executor.execute(Runnable)调用异步执行ftask所代表的任务，然后返回ftask,以便该方法的调用方能够获取任务的执行结果

FutureTask还支持以回调(Callback)的方式处理任务的执行结果。当FutureTask实例所代表的任务执行结束后，FutureTask.done()会被执行。FutureTask.done()是个protected方法，FutureTask子类可以覆盖该方法并在其中实现对任务执行结果的处理。FutureTask.done()中的代码可以通过FutureTask.get()调用来获取任务的执行结果，此时由于任务已经执行结束，因此FutureTask.get()调用并不会使得当前线程暂停。但是，由于任务的执行结束既包括正常终止，也包括异常终止以及任务被取消而导致的终止，因此FutureTask.done()方法中的代码可能需要在调用FutureTask.get()前调用FutureTask.isCancelled()来判断任务是否被取消，以免FutureTask.get()调用抛出CancellationException异常(运行时异常)

```
    public static String doSomethingA() {
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("--- doSomethingA---");
        return "TaskAResult";
    }
    public static String doSomethingB() {
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("--- doSomethingB---");
        return "TaskBResult";
    }
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        long start = System.currentTimeMillis();
        // 1.创建future任务
        FutureTask<String> futureTask = new FutureTask<String>(() -> {
            String result = null;
            try {
                result = doSomethingA();
            } catch (Exception e) {
                e.printStackTrace(); }
            return result;
        });
        // 2.开启异步单元执行任务A
        Thread thread = new Thread(futureTask, "threadA");
        thread.start();
        // 3.执行任务B
        String taskBResult = doSomethingB();
        // 4.同步等待线程A运行结束
        String taskAResult = futureTask.get();
        // 5.打印两个任务执行结果
        System.out.println(taskAResult + " " + taskBResult);
        System.out.println(System.currentTimeMillis() - start);
    }
```

```
    public static String doSomethingA() {
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("--- doSomethingA---");
        return "TaskAResult";
    }
    public static String doSomethingB() {
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("--- doSomethingB---");
        return "TaskBResult";
    }
    private final static int AVALIABLE_PROCESSORS =
            Runtime.getRuntime().availableProcessors();
    private final static
    ThreadPoolExecutor POOL_EXECUTOR = new ThreadPoolExecutor(AVALIABLE_PROCESSORS,
            AVALIABLE_PROCESSORS * 2,
            1,
            TimeUnit.MINUTES,
            new LinkedBlockingQueue<>(5),
            new ThreadPoolExecutor.CallerRunsPolicy());
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        long start = System.currentTimeMillis();
        // 1.创建future任务
        FutureTask<String> futureTask = new FutureTask<String>(() -> {
            String result = null;
            try {
                result = doSomethingA();
            } catch (Exception e) {
                e.printStackTrace(); }
            return result;
        });
        // 2.开启异步单元执行任务A
        POOL_EXECUTOR.execute(futureTask);
        // 3.执行任务B
        String taskBResult = doSomethingB();
        // 4.同步等待线程A运行结束
        String taskAResult = futureTask.get(); // 5.打印两个任务执行结果
        System.out.println(taskAResult + " " + taskBResult);
        System.out.println(System.currentTimeMillis() - start); 
    }
```

```
    public static String doSomethingA() {
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("--- doSomethingA---");
        return "TaskAResult";
    }
    public static String doSomethingB() {
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("--- doSomethingB---");
        return "TaskBResult";
    }
    private final static int AVALIABLE_PROCESSORS =
            Runtime.getRuntime().availableProcessors();
    private final static
    ThreadPoolExecutor POOL_EXECUTOR = new ThreadPoolExecutor(AVALIABLE_PROCESSORS,
            AVALIABLE_PROCESSORS * 2,
            1,
            TimeUnit.MINUTES,
            new LinkedBlockingQueue<>(5),
            new ThreadPoolExecutor.CallerRunsPolicy());
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        long start = System.currentTimeMillis();
        // 1.开启异步单元执行任务A
        Future<String> futureTask = POOL_EXECUTOR.submit(() -> {
            String result = null;
            try {
                result = doSomethingA();
            } catch (Exception e) {
                e.printStackTrace(); }
            return result;
        });
        // 2.执行任务B
        String taskBResult = doSomethingB();
        // 3.同步等待线程A运行结束
        String taskAResult = futureTask.get(); // 4.打印两个任务执行结果
        System.out.println(taskAResult + " " + taskBResult);
        System.out.println(System.currentTimeMillis() - start); 
    }
```

##### CompletableFuture

FutureTask虽然集合了Runnable、Callable和Future接口的优点，但为了获取结果，必须调用get()方法，只能通过阻塞或者轮询的方式得到任务的结果。阻塞的方式显然和我们异步编程的初衷相违背，轮询的方式又会耗费无谓的CPU资源，而且也不能及时的获取结果

为了克服Future Task的局限性，以及满足我们对异步编程的需求，JDK8中新增了一个包含50多个方法的类：CompletableFuture，提供了非常强大的Future扩展功能，可以帮助我们简化异步编程的复杂性，提供函数式编程的能力

```
public class CompletableFuture<T> implements Future<T>, CompletionStage<T>
```

CompletableFuture实现了Future接口，拥有Future所有的特性，比如可以使用get()方法获取返回值等；还实现了CompletionStage接口，这个接口有超过40个方法，功能十分丰富，它主要是为了编排任务的工作流

可以把工作流和工作流之间的关系分类为三种：串行关系，并行关系，汇聚关系

汇聚关系，又分为AND汇聚关系和OR汇聚关系：AND汇聚关系，就是所有依赖的任务都完成之后再执行；OR汇聚关系，就是依赖的任务中有一个执行完成，就开始执行

###### 显式设置CompletableFuture结果

```

    private final static int AVAILABLE_PROCESSORS =
            Runtime.getRuntime().availableProcessors();
    private final static ThreadPoolExecutor POOL_EXECUTOR =
            new ThreadPoolExecutor(AVAILABLE_PROCESSORS,
                    AVAILABLE_PROCESSORS * 2,
                    10,
                    TimeUnit.SECONDS,
                    new LinkedBlockingQueue<>(5),
                    new ThreadPoolExecutor.CallerRunsPolicy());

    public static void main(String[] args) throws InterruptedException, ExecutionException, TimeoutException {
        // 1.创建一个CompletableFuture对象
        CompletableFuture<String> future = new CompletableFuture<String>();
        // 2.开启线程计算任务结果，并设置
        POOL_EXECUTOR.execute(() -> {
            // 2.1休眠3s，模拟任务计算
            try {
                Thread.sleep(3000);
            } catch (InterruptedException e) {
                //
            }
            // 2.2设置计算结果到future
            System.out.println("----" + Thread.currentThread().getName() +  " set future result----");
            future.complete("hello, Tom");
        });
        // 3.等待计算结果
        System.out.println("---main thread wait future result---");
        System.out.println(future.get());
        System.out.println("---main thread got future result---");
    }
```

###### ForkJoinPool

默认情况下，CompletableFuture异步运行使用的是ForkJoinPool。ForkJoinPool本身也是一种ExecutorService，与其他ExecutorService实例（比如ThreadPoolExecutor）相比，不同点是它使用了工作窃取算法来提高性能，其内部每个工作线程都关联自己的内存队列，正常情况下每个线程从自己队列里面获取任务并执行，当本身队列没有任务时，当前线程会去其他线程关联的队列里面获取任务来执行。这在很多任务会产生子任务或者有很多小的任务被提交到线程池来执行的情况下非常高效

ForkJoinPool中有一个静态的线程池commonPool可用且适用大多数情况。commonPool会被任何未显式提交到指定线程池的ForkJoinTask执行使用。使用commonPool通常会减少资源使用（其线程数量会在不活跃时缓慢回收，并在任务数比较多的时候按需增加）

**ForkJoinPool.commonPool()线程池在JVM中是唯一的**

当我们使用CompletableFuture实现异步编程时，大多数时候是不需要显式创建线程池，并投递任务到线程池内的。只需要简单地调用CompletableFuture的runAsync或者supplyAsync等方法把异步任务作为参数即可，其内部会使用ForkJoinPool线程池来进行异步执行，这大大简化了异步编程的负担，实现了声明式编程（告诉程序我要执行异步任务，但是具体怎么实现我不需要管），当然如果你想使用自己的线程池来执行任务，也是可以非常方便地进行设置的

###### 提交执行的静态方法

| 方法名 | 描述 |
| :----: | :----: |
| runAsync(Runnable runnable) | 执行异步代码，使用 ForkJoinPool.commonPool() 作为它的线程池 |
| runAsync(Runnable runnable, Executor executor) | 执行异步代码，使用指定的线程池 |
| supplyAsync(Supplier<U> supplier) | 异步执行代码，有返回值，使用 ForkJoinPool.commonPool() 作为它的线程池 |
| supplyAsync(Supplier<U> supplier, Executor executor) | 异步执行代码，有返回值，使用指定的线程池执行 |

上述四个方法，都是提交任务的，runAsync方法需要传入一个实现了Runnable接口的实例；supplyAsync需要传入一个实现了Supplier接口的实例

**run 和 supply 的区别**

run就是一个执行方法，没有返回值，supply也是一个执行方法，有返回值

**一个参数和两个参数的区别**

第二个参数是线程池，如果没有传，则使用自带的ForkJoinPool.commonPool()作为线程池，这个线程池默认创建的线程数是CPU的核数

###### 基于CompletableFuture实现异步计算与结果转换

1. 基于runAsync系列方法实现无返回值的异步计算

```
    public static void main(String[] args) throws InterruptedException, ExecutionException, TimeoutException {
        CompletableFuture<Void> future = CompletableFuture.runAsync(new Runnable() {
            @Override
            public void run() {
                // 1.1.1休眠2s模拟任务计算
                try {
                    Thread.sleep(2000); } catch (InterruptedException e) {
                    e.printStackTrace(); }
                System.out.println("over"); }
        });
        // 1.2 同步等待异步任务执行结束
        System.out.println(future.get());
    }
```

```
    private static final ThreadPoolExecutor bizPoolExecutor =
            new ThreadPoolExecutor(8,
                    8,
                    1,
                    TimeUnit.MINUTES,
                    new LinkedBlockingQueue<>(10));

    public static void main(String[] args) throws InterruptedException, ExecutionException, TimeoutException {
        // 1.1创建异步任务，并返回future
        CompletableFuture<Void> future = CompletableFuture.runAsync(new Runnable() {
            @Override
            public void run() {
                // 1.1.1休眠2s模拟任务计算
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("over"); }
        }, bizPoolExecutor);
        // 1.2 同步等待异步任务执行结束
        System.out.println(future.get());
    }
```

2. 基于supplyAsync系列方法实现有返回值的异步计算

```
    public static void main(String[] args) throws InterruptedException, ExecutionException, TimeoutException {
        // 2.1创建异步任务，并返回future
        CompletableFuture<String> future = CompletableFuture.supplyAsync(new Supplier<String>
                () {
            @Override
            public String get() {
                // 2.1.1休眠2s模拟任务计算
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    // TODO Auto-generated catch block e.printStackTrace();
                }
                // 2.1.2 返回异步计算结果
                return "hello,jiaduo";
            }
        });
        // 2.2 同步等待异步任务执行结束
        System.out.println(future.get());
    }
```

```
    private static final ThreadPoolExecutor bizPoolExecutor = new
            ThreadPoolExecutor(8,
            8,
            1,
            TimeUnit.MINUTES,
            new LinkedBlockingQueue<>(10));

    public static void main(String[] args) throws InterruptedException, ExecutionException, TimeoutException {
        // 2.1创建异步任务，并返回future
        CompletableFuture<String> future = CompletableFuture.supplyAsync(new Supplier<String>
                () {
            @Override
            public String get() {
                // 2.1.1休眠2s模拟任务计算
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    // TODO Auto-generated catch block e.printStackTrace();
                }
                // 2.1.2 返回异步计算结果
                return "hello,jiaduo";
            }
        }, bizPoolExecutor);
        // 2.2 同步等待异步任务执行结束
        System.out.println(future.get());
    }
```

###### Async后缀方法和不带Async后缀方法的区别

CompletableFuture提供的所有回调方法都有两个变体：是否有Async后缀。两种变体的区别是：**在于谁去执行任务**

如果使用不带Async后缀的方法，即同步回调，如果提交任务的方法（runAsync或者supplyAsync）执行速度特别快，那么不带Async后缀的回调任务就使用提交该回调任务的线程执行；如果提交任务的方法（runAsync或者supplyAsync）执行速度特别慢，那么不带Async后缀的回调任务则使用上一个回调任务执行的线程执行，也就是和上一个回调任务使用的是同一个线程

```
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        System.out.println(Thread.currentThread().getName());
        System.out.println("----------supplyAsync 执行很快");
        CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> {
            System.out.println(Thread.currentThread().getName());
            return "1";
        }).thenApply(s -> {
            System.out.println(Thread.currentThread().getName());
            return "2";
        });
        System.out.println(future1.get());

        System.out.println("----------supplyAsync 执行很慢");
        CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
            }
            System.out.println(Thread.currentThread().getName());
            return "1";
        }).thenApply(s -> {
            System.out.println(Thread.currentThread().getName());
            return "2";
        });
        System.out.println(future2.get());
    }
```

如果使用带Async后缀的方法，那么该回调都作为单独的任务提交给ForkJoinPool.commonPool()或者自己定义的线程池中，使用独立的线程去执行

https://www.jdon.com/50027
https://juejin.cn/post/6844903594165026829

```
    public static void main(String[] args) throws Exception {
        CompletableFuture<Integer> f = new CompletableFuture<Integer>();

        new Thread(() -> {
            // 子线程启动
            try {
                Thread.sleep(1000);//1秒
            } catch (InterruptedException interruptedException) {
                interruptedException.printStackTrace();
            }
            f.complete(100);
            // 当子线程执行到f.complete的时候，会去看是否有注册好的f的then或者when（非async的），如果有的话，会顺次去执行。
        }, "son thread").start();

        try {
            Thread.sleep(5000);//5秒
        } catch (InterruptedException interruptedException) {
            interruptedException.printStackTrace();
        }

        // 当前线程（主线程）执行到这里的时候，如果子线程还没有执行到f.complete(100)，
        // 那么当前线程会把whenComplete事件注册起来，并且说好哪个线程执行了f.complete(100)，
        // 哪个线程就负责执行whenComplete的内容。
        // 如果当前线程（主线程）执行到这里的时候，f.complete(100)已经被其他线程执行完毕了。
        // 那么只有当前线程自己来执行whenComplete里面的内容了。
        f.whenComplete((i, ex) -> {
            // 这个场景下，whenComplete的回调的执行线程会是主线程
            System.out.println(Thread.currentThread().getName());
        });

    }
```

```
    public static void main(String[] args) throws Exception {
        CompletableFuture<Integer> f = new CompletableFuture<Integer>();

        new Thread(() -> {
            // 子线程启动
            try {
                Thread.sleep(5000);//5秒
            } catch (InterruptedException interruptedException) {
                interruptedException.printStackTrace();
            }
            f.complete(100);
            // 当子线程执行到f.complete的时候，会去看是否有注册好的f的then或者when（非async的），如果有的话，会顺次去执行。
        }, "son thread").start();

        // 当前线程（主线程）执行到这里的时候，如果子线程还没有执行到f.complete(100)，
        // 那么当前线程会把whenComplete事件注册起来，并且说好哪个线程执行了f.complete(100)，
        // 哪个线程就负责执行whenComplete的内容。
        // 如果当前线程（主线程）执行到这里的时候，f.complete(100)已经被其他线程执行完毕了。
        // 那么只有当前线程自己来执行whenComplete里面的内容了。
        f.whenComplete((i, ex) -> {
            // 这个场景下，whenComplete的回调的执行线程会是子线程
            System.out.println(Thread.currentThread().getName());
        });

    }
```

https://blog.csdn.net/leon_wzm/article/details/80560081

###### 串行关系api

| api | 是否可获得前一个任务的返回值 | 是否有返回值 |
| :----: | :----: | :----: |
| thenApply | 能 | 单元格 |
| thenAccept | 单元格 | 单元格 |
| thenRun | 单元格 | 单元格 |
| thenCompose | 单元格 | 单元格 |

1. 基于thenRun实现异步任务A，执行完毕后，激活异步任务B执行，需要注意的是，这种方式激活的异步任务B是拿不到任务A的执行结果

```
    public static void main(String[] args) throws InterruptedException, ExecutionException, TimeoutException {
        // 1.创建异步任务，并返回future
        CompletableFuture<String> oneFuture = CompletableFuture.supplyAsync(new Supplier<String>() {
            @Override
                        public String get() {
                            // 1.1休眠2s，模拟任务计算
                            try {
                                Thread.sleep(2000); } catch (InterruptedException e) {
                                e.printStackTrace(); }
                            // 1.2返回计算结果
                            return "hello";
                        }
                    });
        // 2.在future上施加事件，当future计算完成后回调该事件，并返回新future
        CompletableFuture<Void> twoFuture = oneFuture.thenRun(new Runnable() {
            @Override
            public void run() {
                // 2.1.1当oneFuture任务计算完成后做一件事情
                try {
                    Thread.sleep(1000); } catch (Exception e) {
                    e.printStackTrace(); }
                System.out.println(Thread.currentThread().getName());
                System.out.println("---after oneFuture over doSomething---"); }
        });
        // 3.同步等待twoFuture对应的任务完成，返回结果固定为null
        System.out.println(twoFuture.get());
    }
```

2. 基于thenAccept实现异步任务A，执行完毕后，激活异步任务B执行，需要注意的是，这种方式激活的异步任务B是可以拿到任务A的执行结果

```
    public static void main(String[] args) throws InterruptedException, ExecutionException, TimeoutException {
        // 1.创建异步任务，并返回future
        CompletableFuture<String> oneFuture = CompletableFuture.supplyAsync(new Supplier<String>() {
            @Override
            public String get() {
                // 1.1休眠2s，模拟任务计算
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                // 1.2返回计算结果
                return "hello";
            }
        });
        // 2.在future上施加事件，当future计算完成后回调该事件，并返回新future
        CompletableFuture<Void> twoFuture = oneFuture.thenAccept(new Consumer<String>() {
            @Override
            public void accept(String t) {
                // 2.1.1对oneFuture返回的结果进行加工
                try {
                    Thread.sleep(1000);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                System.out.println("---after oneFuture over doSomething---" + t); }
        });
        // 3.同步等待twoFuture对应的任务完成，返回结果固定为null
        System.out.println(twoFuture.get());
    }
```

3. 基于thenApply实现异步任务A，执行完毕后，激活异步任务B执行。需要注意的是，这种方式激活的异步任务B是可以拿到任务A的执行结果的，并且可以获取到异步任务B的执行结果

```
    public static void main(String[] args) throws InterruptedException, ExecutionException, TimeoutException {
        // 1.创建异步任务，并返回future
        CompletableFuture<String> oneFuture = CompletableFuture.supplyAsync(new
        Supplier<String>() {
            @Override
            public String get() {
                // 1.1休眠2s，模拟任务计算
                try {
                    Thread.sleep(2000); } catch (InterruptedException e) {
                    e.printStackTrace(); }
                // 1.2返回计算结果
                return "hello";
            }
        });
        // 2.在future上施加事件，当future计算完成后回调该事件，并返回新future
        CompletableFuture<String> twoFuture = oneFuture.thenApply(new Function<String,
                        String>() {
            // 2.1在步骤1计算结果基础上进行计算，这里t为步骤1返回的hello 
            @Override
            public String apply(String t) {
                // 2.1.1对oneFuture返回的结果进行加工
                try {
                    Thread.sleep(1000); } catch (Exception e) {
                    e.printStackTrace(); }
                // 2.1.2返回加工后结果
                return t + " jiduo";
            }
        });
        // 3.同步等待twoFuture对应的任务完成，并获取结果
        System.out.println(twoFuture.get());
    }
```

4. thenCompose

thenCompose与thenApply类似，但区别如下：

```
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CompletableFuture<String> future = getLastOne().thenCompose(ThreadImp::getLastTwo);
        System.out.println(future.get());

        CompletableFuture<CompletableFuture<String>> future2 = getLastOne().thenApply(ThreadImp::getLastTwo);
        System.out.println(future2.get().get());
    }

    public static CompletableFuture<String> getLastOne(){
        return CompletableFuture.supplyAsync(()-> "topOne");
    }

    public static CompletableFuture<String> getLastTwo(String s){
        return CompletableFuture.supplyAsync(()-> s + "  topTwo");
    }
```

可以看到使用 thenApply 的时候，需要使用两个 get() 方法才能获取到最终的返回值，使用 thenCompose 只要一个即可

```
    // 1.异步任务，返回future
    public static CompletableFuture<String> doSomethingOne(String encodedCompanyId) {
        // 1.1创建异步任务
        return CompletableFuture.supplyAsync(new Supplier<String>() {
            @Override
            public String get() {
                // 1.1.1休眠1s，模拟任务计算
                try {
                    Thread.sleep(1000); } catch (InterruptedException e) {
                    e.printStackTrace(); }
                // 1.1.2 解密，并返回结果
                return encodedCompanyId;
            }
        });
    }
    // 2.开启异步任务，返回future
    public static CompletableFuture<String> doSomethingTwo(String companyId) {
        return CompletableFuture.supplyAsync(new Supplier<String>() {
            @Override
            public String get() {
                // 2.1 休眠3s，模拟计算
                try {
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                // 2.2 查询公司信息，转换为str，并返回
                return companyId + ":alibaba";
            }
        });
    }



    public static void main(String[] args) throws InterruptedException, ExecutionException {
        CompletableFuture<String> result = doSomethingOne("123").thenCompose(new Function<String, CompletionStage<String>>() {
            @Override
            public CompletionStage<String> apply(String s) {
                return doSomethingTwo("this is a string");
            }
        });
        CompletableFuture<String> result2 = doSomethingOne("123").thenApply(new Function<String, String>() {
            @Override
            public String apply(String s) {

                String r = null;
                try {
                    r = doSomethingTwo("this is a string").get();
                } catch (InterruptedException interruptedException) {
                    interruptedException.printStackTrace();
                } catch (ExecutionException e) {
                    e.printStackTrace();
                }
                return r;
            }
        });
        System.out.println(result.get());
    }
```

https://blog.csdn.net/weixin_30387339/article/details/99083298

5. 基于whenComplete设置回调函数，当异步任务执行完毕后进行回调

```
    public static void main(String[] args) throws InterruptedException, ExecutionException, TimeoutException {
        // 1.创建一个CompletableFuture对象
        CompletableFuture<String> future = CompletableFuture.supplyAsync(new Supplier<String>() {
             @Override
             public String get() {
                 // 1.1模拟异步任务执行
                 try {
                     Thread.sleep(1000);
                 } catch (InterruptedException e) {
                     e.printStackTrace();
                 }
                 // 1.2返回计算结果
                 return "hello, Tom";
             }
         });
        // 2.添加回调函数
        future.whenComplete(new BiConsumer<String, Throwable>() {
            @Override
            public void accept(String t, Throwable u) {
                // 2.1如果没有异常，打印异步任务结果
                if (null == u) {
                    System.out.println(t); } else {
                    // 2.2打印异常信息
                    System.out.println(u.getLocalizedMessage());
                }
            }
        });
        // 3.挂起当前线程，等待异步任务执行完毕
        Thread.currentThread().join();
    }
```

###### 并行关系api

**多线程异步执行就是并行关系**

###### And汇聚关系Api

thenCombine
thenAcceptBoth
runAfterBoth

###### Or汇聚关系Api

applyToEither
acceptEither
runAfterEither

https://mp.weixin.qq.com/s/7fEtXDQMWoay8zFN3x6bXw

https://www.cnblogs.com/yulinfeng/p/7039979.html
https://www.cnblogs.com/pcheng/p/13540619.html